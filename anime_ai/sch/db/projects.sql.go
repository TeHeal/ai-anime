// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
    user_id, name, story, story_mode, config_json, props_json, storyboard_json,
    mirror_mode, team_id, visibility, version,
    story_locked, story_locked_at, assets_locked, assets_locked_at, script_locked, script_locked_at
)
VALUES (
    $1, $2, $3, $4,
    COALESCE($5, '{}'), COALESCE($6, '{}'), COALESCE($7, '{}'),
    COALESCE($8, true), $9, COALESCE($10, 'private'), COALESCE($11, 1),
    COALESCE($12, false), $13,
    COALESCE($14, false), $15,
    COALESCE($16, false), $17
)
RETURNING id, created_at, updated_at, deleted_at, user_id, name, story, story_mode, config_json, props_json, storyboard_json, mirror_mode, team_id, visibility, version, story_locked, story_locked_at, assets_locked, assets_locked_at, script_locked, script_locked_at
`

type CreateProjectParams struct {
	UserID         pgtype.UUID        `json:"user_id"`
	Name           string             `json:"name"`
	Story          pgtype.Text        `json:"story"`
	StoryMode      pgtype.Text        `json:"story_mode"`
	ConfigJson     interface{}        `json:"config_json"`
	PropsJson      interface{}        `json:"props_json"`
	StoryboardJson interface{}        `json:"storyboard_json"`
	MirrorMode     interface{}        `json:"mirror_mode"`
	TeamID         pgtype.UUID        `json:"team_id"`
	Visibility     interface{}        `json:"visibility"`
	Version        interface{}        `json:"version"`
	StoryLocked    interface{}        `json:"story_locked"`
	StoryLockedAt  pgtype.Timestamptz `json:"story_locked_at"`
	AssetsLocked   interface{}        `json:"assets_locked"`
	AssetsLockedAt pgtype.Timestamptz `json:"assets_locked_at"`
	ScriptLocked   interface{}        `json:"script_locked"`
	ScriptLockedAt pgtype.Timestamptz `json:"script_locked_at"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.UserID,
		arg.Name,
		arg.Story,
		arg.StoryMode,
		arg.ConfigJson,
		arg.PropsJson,
		arg.StoryboardJson,
		arg.MirrorMode,
		arg.TeamID,
		arg.Visibility,
		arg.Version,
		arg.StoryLocked,
		arg.StoryLockedAt,
		arg.AssetsLocked,
		arg.AssetsLockedAt,
		arg.ScriptLocked,
		arg.ScriptLockedAt,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Name,
		&i.Story,
		&i.StoryMode,
		&i.ConfigJson,
		&i.PropsJson,
		&i.StoryboardJson,
		&i.MirrorMode,
		&i.TeamID,
		&i.Visibility,
		&i.Version,
		&i.StoryLocked,
		&i.StoryLockedAt,
		&i.AssetsLocked,
		&i.AssetsLockedAt,
		&i.ScriptLocked,
		&i.ScriptLockedAt,
	)
	return i, err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, created_at, updated_at, deleted_at, user_id, name, story, story_mode, config_json, props_json, storyboard_json, mirror_mode, team_id, visibility, version, story_locked, story_locked_at, assets_locked, assets_locked_at, script_locked, script_locked_at FROM projects
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProjectByID(ctx context.Context, id pgtype.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Name,
		&i.Story,
		&i.StoryMode,
		&i.ConfigJson,
		&i.PropsJson,
		&i.StoryboardJson,
		&i.MirrorMode,
		&i.TeamID,
		&i.Visibility,
		&i.Version,
		&i.StoryLocked,
		&i.StoryLockedAt,
		&i.AssetsLocked,
		&i.AssetsLockedAt,
		&i.ScriptLocked,
		&i.ScriptLockedAt,
	)
	return i, err
}

const getProjectByIDAndUser = `-- name: GetProjectByIDAndUser :one
SELECT id, created_at, updated_at, deleted_at, user_id, name, story, story_mode, config_json, props_json, storyboard_json, mirror_mode, team_id, visibility, version, story_locked, story_locked_at, assets_locked, assets_locked_at, script_locked, script_locked_at FROM projects
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type GetProjectByIDAndUserParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetProjectByIDAndUser(ctx context.Context, arg GetProjectByIDAndUserParams) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByIDAndUser, arg.ID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Name,
		&i.Story,
		&i.StoryMode,
		&i.ConfigJson,
		&i.PropsJson,
		&i.StoryboardJson,
		&i.MirrorMode,
		&i.TeamID,
		&i.Visibility,
		&i.Version,
		&i.StoryLocked,
		&i.StoryLockedAt,
		&i.AssetsLocked,
		&i.AssetsLockedAt,
		&i.ScriptLocked,
		&i.ScriptLockedAt,
	)
	return i, err
}

const listProjectsByUser = `-- name: ListProjectsByUser :many
SELECT id, created_at, updated_at, deleted_at, user_id, name, story, story_mode, config_json, props_json, storyboard_json, mirror_mode, team_id, visibility, version, story_locked, story_locked_at, assets_locked, assets_locked_at, script_locked, script_locked_at FROM projects
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY updated_at DESC
`

func (q *Queries) ListProjectsByUser(ctx context.Context, userID pgtype.UUID) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.Name,
			&i.Story,
			&i.StoryMode,
			&i.ConfigJson,
			&i.PropsJson,
			&i.StoryboardJson,
			&i.MirrorMode,
			&i.TeamID,
			&i.Visibility,
			&i.Version,
			&i.StoryLocked,
			&i.StoryLockedAt,
			&i.AssetsLocked,
			&i.AssetsLockedAt,
			&i.ScriptLocked,
			&i.ScriptLockedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByUserOrMember = `-- name: ListProjectsByUserOrMember :many
SELECT p.id, p.created_at, p.updated_at, p.deleted_at, p.user_id, p.name, p.story, p.story_mode, p.config_json, p.props_json, p.storyboard_json, p.mirror_mode, p.team_id, p.visibility, p.version, p.story_locked, p.story_locked_at, p.assets_locked, p.assets_locked_at, p.script_locked, p.script_locked_at FROM projects p
LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.user_id = $1 AND pm.deleted_at IS NULL
WHERE (p.user_id = $1 OR pm.id IS NOT NULL) AND p.deleted_at IS NULL
ORDER BY p.updated_at DESC
`

func (q *Queries) ListProjectsByUserOrMember(ctx context.Context, userID pgtype.UUID) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectsByUserOrMember, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.Name,
			&i.Story,
			&i.StoryMode,
			&i.ConfigJson,
			&i.PropsJson,
			&i.StoryboardJson,
			&i.MirrorMode,
			&i.TeamID,
			&i.Visibility,
			&i.Version,
			&i.StoryLocked,
			&i.StoryLockedAt,
			&i.AssetsLocked,
			&i.AssetsLockedAt,
			&i.ScriptLocked,
			&i.ScriptLockedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProject = `-- name: SoftDeleteProject :exec
UPDATE projects
SET deleted_at = now()
WHERE id = $1 AND user_id = $2
`

type SoftDeleteProjectParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) SoftDeleteProject(ctx context.Context, arg SoftDeleteProjectParams) error {
	_, err := q.db.Exec(ctx, softDeleteProject, arg.ID, arg.UserID)
	return err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET
    name = COALESCE($1, name),
    story = COALESCE($2, story),
    story_mode = COALESCE($3, story_mode),
    config_json = COALESCE($4, config_json),
    props_json = COALESCE($5, props_json),
    storyboard_json = COALESCE($6, storyboard_json),
    mirror_mode = COALESCE($7, mirror_mode),
    team_id = COALESCE($8, team_id),
    visibility = COALESCE($9, visibility),
    version = COALESCE($10, version),
    story_locked = COALESCE($11, story_locked),
    story_locked_at = $12,
    assets_locked = COALESCE($13, assets_locked),
    assets_locked_at = $14,
    script_locked = COALESCE($15, script_locked),
    script_locked_at = $16
WHERE id = $17 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, user_id, name, story, story_mode, config_json, props_json, storyboard_json, mirror_mode, team_id, visibility, version, story_locked, story_locked_at, assets_locked, assets_locked_at, script_locked, script_locked_at
`

type UpdateProjectParams struct {
	Name           pgtype.Text        `json:"name"`
	Story          pgtype.Text        `json:"story"`
	StoryMode      pgtype.Text        `json:"story_mode"`
	ConfigJson     []byte             `json:"config_json"`
	PropsJson      []byte             `json:"props_json"`
	StoryboardJson []byte             `json:"storyboard_json"`
	MirrorMode     pgtype.Bool        `json:"mirror_mode"`
	TeamID         pgtype.UUID        `json:"team_id"`
	Visibility     pgtype.Text        `json:"visibility"`
	Version        pgtype.Int4        `json:"version"`
	StoryLocked    pgtype.Bool        `json:"story_locked"`
	StoryLockedAt  pgtype.Timestamptz `json:"story_locked_at"`
	AssetsLocked   pgtype.Bool        `json:"assets_locked"`
	AssetsLockedAt pgtype.Timestamptz `json:"assets_locked_at"`
	ScriptLocked   pgtype.Bool        `json:"script_locked"`
	ScriptLockedAt pgtype.Timestamptz `json:"script_locked_at"`
	ID             pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.Name,
		arg.Story,
		arg.StoryMode,
		arg.ConfigJson,
		arg.PropsJson,
		arg.StoryboardJson,
		arg.MirrorMode,
		arg.TeamID,
		arg.Visibility,
		arg.Version,
		arg.StoryLocked,
		arg.StoryLockedAt,
		arg.AssetsLocked,
		arg.AssetsLockedAt,
		arg.ScriptLocked,
		arg.ScriptLockedAt,
		arg.ID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Name,
		&i.Story,
		&i.StoryMode,
		&i.ConfigJson,
		&i.PropsJson,
		&i.StoryboardJson,
		&i.MirrorMode,
		&i.TeamID,
		&i.Visibility,
		&i.Version,
		&i.StoryLocked,
		&i.StoryLockedAt,
		&i.AssetsLocked,
		&i.AssetsLockedAt,
		&i.ScriptLocked,
		&i.ScriptLockedAt,
	)
	return i, err
}
