// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: shot_images.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createShotImage = `-- name: CreateShotImage :one

INSERT INTO shot_images (
    shot_id, project_id, image_url, task_id, status, provider, model,
    prompt, negative_prompt, params_json, version,
    review_status, review_comment, reviewed_at, reviewed_by
)
VALUES (
    $1, $2, $3,
    $4, COALESCE($5, 'pending'),
    $6, $7, $8,
    $9, COALESCE($10, '{}'),
    COALESCE($11, 1), $12,
    $13, $14, $15
)
RETURNING id, created_at, updated_at, deleted_at, shot_id, project_id, image_url, task_id, status, provider, model, prompt, negative_prompt, params_json, version, review_status, review_comment, reviewed_at, reviewed_by
`

type CreateShotImageParams struct {
	ShotID         pgtype.UUID        `json:"shot_id"`
	ProjectID      pgtype.UUID        `json:"project_id"`
	ImageUrl       string             `json:"image_url"`
	TaskID         pgtype.Text        `json:"task_id"`
	Status         interface{}        `json:"status"`
	Provider       pgtype.Text        `json:"provider"`
	Model          pgtype.Text        `json:"model"`
	Prompt         pgtype.Text        `json:"prompt"`
	NegativePrompt pgtype.Text        `json:"negative_prompt"`
	ParamsJson     interface{}        `json:"params_json"`
	Version        interface{}        `json:"version"`
	ReviewStatus   pgtype.Text        `json:"review_status"`
	ReviewComment  pgtype.Text        `json:"review_comment"`
	ReviewedAt     pgtype.Timestamptz `json:"reviewed_at"`
	ReviewedBy     pgtype.UUID        `json:"reviewed_by"`
}

// 镜图 CRUD（每个镜头的关键帧图像）
func (q *Queries) CreateShotImage(ctx context.Context, arg CreateShotImageParams) (ShotImage, error) {
	row := q.db.QueryRow(ctx, createShotImage,
		arg.ShotID,
		arg.ProjectID,
		arg.ImageUrl,
		arg.TaskID,
		arg.Status,
		arg.Provider,
		arg.Model,
		arg.Prompt,
		arg.NegativePrompt,
		arg.ParamsJson,
		arg.Version,
		arg.ReviewStatus,
		arg.ReviewComment,
		arg.ReviewedAt,
		arg.ReviewedBy,
	)
	var i ShotImage
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ShotID,
		&i.ProjectID,
		&i.ImageUrl,
		&i.TaskID,
		&i.Status,
		&i.Provider,
		&i.Model,
		&i.Prompt,
		&i.NegativePrompt,
		&i.ParamsJson,
		&i.Version,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const getShotImageByID = `-- name: GetShotImageByID :one
SELECT id, created_at, updated_at, deleted_at, shot_id, project_id, image_url, task_id, status, provider, model, prompt, negative_prompt, params_json, version, review_status, review_comment, reviewed_at, reviewed_by FROM shot_images
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetShotImageByID(ctx context.Context, id pgtype.UUID) (ShotImage, error) {
	row := q.db.QueryRow(ctx, getShotImageByID, id)
	var i ShotImage
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ShotID,
		&i.ProjectID,
		&i.ImageUrl,
		&i.TaskID,
		&i.Status,
		&i.Provider,
		&i.Model,
		&i.Prompt,
		&i.NegativePrompt,
		&i.ParamsJson,
		&i.Version,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const listShotImagesByProject = `-- name: ListShotImagesByProject :many
SELECT id, created_at, updated_at, deleted_at, shot_id, project_id, image_url, task_id, status, provider, model, prompt, negative_prompt, params_json, version, review_status, review_comment, reviewed_at, reviewed_by FROM shot_images
WHERE project_id = $1 AND deleted_at IS NULL
ORDER BY created_at ASC
`

func (q *Queries) ListShotImagesByProject(ctx context.Context, projectID pgtype.UUID) ([]ShotImage, error) {
	rows, err := q.db.Query(ctx, listShotImagesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShotImage{}
	for rows.Next() {
		var i ShotImage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ShotID,
			&i.ProjectID,
			&i.ImageUrl,
			&i.TaskID,
			&i.Status,
			&i.Provider,
			&i.Model,
			&i.Prompt,
			&i.NegativePrompt,
			&i.ParamsJson,
			&i.Version,
			&i.ReviewStatus,
			&i.ReviewComment,
			&i.ReviewedAt,
			&i.ReviewedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShotImagesByShot = `-- name: ListShotImagesByShot :many
SELECT id, created_at, updated_at, deleted_at, shot_id, project_id, image_url, task_id, status, provider, model, prompt, negative_prompt, params_json, version, review_status, review_comment, reviewed_at, reviewed_by FROM shot_images
WHERE shot_id = $1 AND deleted_at IS NULL
ORDER BY version ASC, created_at ASC
`

func (q *Queries) ListShotImagesByShot(ctx context.Context, shotID pgtype.UUID) ([]ShotImage, error) {
	rows, err := q.db.Query(ctx, listShotImagesByShot, shotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShotImage{}
	for rows.Next() {
		var i ShotImage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ShotID,
			&i.ProjectID,
			&i.ImageUrl,
			&i.TaskID,
			&i.Status,
			&i.Provider,
			&i.Model,
			&i.Prompt,
			&i.NegativePrompt,
			&i.ParamsJson,
			&i.Version,
			&i.ReviewStatus,
			&i.ReviewComment,
			&i.ReviewedAt,
			&i.ReviewedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteShotImage = `-- name: SoftDeleteShotImage :exec
UPDATE shot_images SET deleted_at = now() WHERE id = $1
`

func (q *Queries) SoftDeleteShotImage(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteShotImage, id)
	return err
}

const softDeleteShotImagesByShot = `-- name: SoftDeleteShotImagesByShot :exec
UPDATE shot_images SET deleted_at = now() WHERE shot_id = $1
`

func (q *Queries) SoftDeleteShotImagesByShot(ctx context.Context, shotID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteShotImagesByShot, shotID)
	return err
}

const updateShotImage = `-- name: UpdateShotImage :one
UPDATE shot_images
SET
    image_url = COALESCE($1, image_url),
    task_id = COALESCE($2, task_id),
    status = COALESCE($3, status),
    provider = COALESCE($4, provider),
    model = COALESCE($5, model),
    prompt = COALESCE($6, prompt),
    negative_prompt = COALESCE($7, negative_prompt),
    params_json = COALESCE($8, params_json),
    version = COALESCE($9, version),
    review_status = COALESCE($10, review_status),
    review_comment = COALESCE($11, review_comment),
    reviewed_at = $12,
    reviewed_by = $13
WHERE id = $14 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, shot_id, project_id, image_url, task_id, status, provider, model, prompt, negative_prompt, params_json, version, review_status, review_comment, reviewed_at, reviewed_by
`

type UpdateShotImageParams struct {
	ImageUrl       pgtype.Text        `json:"image_url"`
	TaskID         pgtype.Text        `json:"task_id"`
	Status         pgtype.Text        `json:"status"`
	Provider       pgtype.Text        `json:"provider"`
	Model          pgtype.Text        `json:"model"`
	Prompt         pgtype.Text        `json:"prompt"`
	NegativePrompt pgtype.Text        `json:"negative_prompt"`
	ParamsJson     []byte             `json:"params_json"`
	Version        pgtype.Int4        `json:"version"`
	ReviewStatus   pgtype.Text        `json:"review_status"`
	ReviewComment  pgtype.Text        `json:"review_comment"`
	ReviewedAt     pgtype.Timestamptz `json:"reviewed_at"`
	ReviewedBy     pgtype.UUID        `json:"reviewed_by"`
	ID             pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateShotImage(ctx context.Context, arg UpdateShotImageParams) (ShotImage, error) {
	row := q.db.QueryRow(ctx, updateShotImage,
		arg.ImageUrl,
		arg.TaskID,
		arg.Status,
		arg.Provider,
		arg.Model,
		arg.Prompt,
		arg.NegativePrompt,
		arg.ParamsJson,
		arg.Version,
		arg.ReviewStatus,
		arg.ReviewComment,
		arg.ReviewedAt,
		arg.ReviewedBy,
		arg.ID,
	)
	var i ShotImage
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ShotID,
		&i.ProjectID,
		&i.ImageUrl,
		&i.TaskID,
		&i.Status,
		&i.Provider,
		&i.Model,
		&i.Prompt,
		&i.NegativePrompt,
		&i.ParamsJson,
		&i.Version,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const updateShotImageReview = `-- name: UpdateShotImageReview :one
UPDATE shot_images
SET review_status = COALESCE($1, review_status),
    review_comment = COALESCE($2, review_comment),
    reviewed_at = $3,
    reviewed_by = $4
WHERE id = $5 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, shot_id, project_id, image_url, task_id, status, provider, model, prompt, negative_prompt, params_json, version, review_status, review_comment, reviewed_at, reviewed_by
`

type UpdateShotImageReviewParams struct {
	ReviewStatus  pgtype.Text        `json:"review_status"`
	ReviewComment pgtype.Text        `json:"review_comment"`
	ReviewedAt    pgtype.Timestamptz `json:"reviewed_at"`
	ReviewedBy    pgtype.UUID        `json:"reviewed_by"`
	ID            pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateShotImageReview(ctx context.Context, arg UpdateShotImageReviewParams) (ShotImage, error) {
	row := q.db.QueryRow(ctx, updateShotImageReview,
		arg.ReviewStatus,
		arg.ReviewComment,
		arg.ReviewedAt,
		arg.ReviewedBy,
		arg.ID,
	)
	var i ShotImage
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ShotID,
		&i.ProjectID,
		&i.ImageUrl,
		&i.TaskID,
		&i.Status,
		&i.Provider,
		&i.Model,
		&i.Prompt,
		&i.NegativePrompt,
		&i.ParamsJson,
		&i.Version,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const updateShotImageStatus = `-- name: UpdateShotImageStatus :one
UPDATE shot_images
SET image_url = COALESCE($1, image_url),
    task_id = COALESCE($2, task_id),
    status = COALESCE($3, status)
WHERE id = $4 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, shot_id, project_id, image_url, task_id, status, provider, model, prompt, negative_prompt, params_json, version, review_status, review_comment, reviewed_at, reviewed_by
`

type UpdateShotImageStatusParams struct {
	ImageUrl pgtype.Text `json:"image_url"`
	TaskID   pgtype.Text `json:"task_id"`
	Status   pgtype.Text `json:"status"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateShotImageStatus(ctx context.Context, arg UpdateShotImageStatusParams) (ShotImage, error) {
	row := q.db.QueryRow(ctx, updateShotImageStatus,
		arg.ImageUrl,
		arg.TaskID,
		arg.Status,
		arg.ID,
	)
	var i ShotImage
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ShotID,
		&i.ProjectID,
		&i.ImageUrl,
		&i.TaskID,
		&i.Status,
		&i.Provider,
		&i.Model,
		&i.Prompt,
		&i.NegativePrompt,
		&i.ParamsJson,
		&i.Version,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}
