// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: review_records.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPendingReviews = `-- name: CountPendingReviews :one
SELECT count(*) FROM review_records WHERE project_id = $1 AND status = 'pending'
`

func (q *Queries) CountPendingReviews(ctx context.Context, projectID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingReviews, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReviewRecord = `-- name: CreateReviewRecord :one
INSERT INTO review_records (project_id, phase, target_type, target_id, reviewer_type, reviewer_id, status, round)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, created_at, updated_at, project_id, phase, target_type, target_id, reviewer_type, reviewer_id, status, ai_score, ai_reason, human_comment, round, decided_at
`

type CreateReviewRecordParams struct {
	ProjectID    pgtype.UUID `json:"project_id"`
	Phase        string      `json:"phase"`
	TargetType   string      `json:"target_type"`
	TargetID     pgtype.UUID `json:"target_id"`
	ReviewerType string      `json:"reviewer_type"`
	ReviewerID   pgtype.UUID `json:"reviewer_id"`
	Status       string      `json:"status"`
	Round        int32       `json:"round"`
}

func (q *Queries) CreateReviewRecord(ctx context.Context, arg CreateReviewRecordParams) (ReviewRecord, error) {
	row := q.db.QueryRow(ctx, createReviewRecord,
		arg.ProjectID,
		arg.Phase,
		arg.TargetType,
		arg.TargetID,
		arg.ReviewerType,
		arg.ReviewerID,
		arg.Status,
		arg.Round,
	)
	var i ReviewRecord
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.Phase,
		&i.TargetType,
		&i.TargetID,
		&i.ReviewerType,
		&i.ReviewerID,
		&i.Status,
		&i.AiScore,
		&i.AiReason,
		&i.HumanComment,
		&i.Round,
		&i.DecidedAt,
	)
	return i, err
}

const getReviewRecord = `-- name: GetReviewRecord :one
SELECT id, created_at, updated_at, project_id, phase, target_type, target_id, reviewer_type, reviewer_id, status, ai_score, ai_reason, human_comment, round, decided_at FROM review_records WHERE id = $1
`

func (q *Queries) GetReviewRecord(ctx context.Context, id pgtype.UUID) (ReviewRecord, error) {
	row := q.db.QueryRow(ctx, getReviewRecord, id)
	var i ReviewRecord
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.Phase,
		&i.TargetType,
		&i.TargetID,
		&i.ReviewerType,
		&i.ReviewerID,
		&i.Status,
		&i.AiScore,
		&i.AiReason,
		&i.HumanComment,
		&i.Round,
		&i.DecidedAt,
	)
	return i, err
}

const listReviewRecordsByProject = `-- name: ListReviewRecordsByProject :many
SELECT id, created_at, updated_at, project_id, phase, target_type, target_id, reviewer_type, reviewer_id, status, ai_score, ai_reason, human_comment, round, decided_at FROM review_records WHERE project_id = $1
ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListReviewRecordsByProjectParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListReviewRecordsByProject(ctx context.Context, arg ListReviewRecordsByProjectParams) ([]ReviewRecord, error) {
	rows, err := q.db.Query(ctx, listReviewRecordsByProject, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReviewRecord{}
	for rows.Next() {
		var i ReviewRecord
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.Phase,
			&i.TargetType,
			&i.TargetID,
			&i.ReviewerType,
			&i.ReviewerID,
			&i.Status,
			&i.AiScore,
			&i.AiReason,
			&i.HumanComment,
			&i.Round,
			&i.DecidedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReviewRecordsByTarget = `-- name: ListReviewRecordsByTarget :many
SELECT id, created_at, updated_at, project_id, phase, target_type, target_id, reviewer_type, reviewer_id, status, ai_score, ai_reason, human_comment, round, decided_at FROM review_records WHERE target_type = $1 AND target_id = $2
ORDER BY round DESC, created_at DESC
`

type ListReviewRecordsByTargetParams struct {
	TargetType string      `json:"target_type"`
	TargetID   pgtype.UUID `json:"target_id"`
}

func (q *Queries) ListReviewRecordsByTarget(ctx context.Context, arg ListReviewRecordsByTargetParams) ([]ReviewRecord, error) {
	rows, err := q.db.Query(ctx, listReviewRecordsByTarget, arg.TargetType, arg.TargetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReviewRecord{}
	for rows.Next() {
		var i ReviewRecord
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.Phase,
			&i.TargetType,
			&i.TargetID,
			&i.ReviewerType,
			&i.ReviewerID,
			&i.Status,
			&i.AiScore,
			&i.AiReason,
			&i.HumanComment,
			&i.Round,
			&i.DecidedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReviewRecordDecision = `-- name: UpdateReviewRecordDecision :exec
UPDATE review_records SET status = $2, ai_score = $3, ai_reason = $4, human_comment = $5, decided_at = now()
WHERE id = $1
`

type UpdateReviewRecordDecisionParams struct {
	ID           pgtype.UUID `json:"id"`
	Status       string      `json:"status"`
	AiScore      pgtype.Int4 `json:"ai_score"`
	AiReason     pgtype.Text `json:"ai_reason"`
	HumanComment pgtype.Text `json:"human_comment"`
}

func (q *Queries) UpdateReviewRecordDecision(ctx context.Context, arg UpdateReviewRecordDecisionParams) error {
	_, err := q.db.Exec(ctx, updateReviewRecordDecision,
		arg.ID,
		arg.Status,
		arg.AiScore,
		arg.AiReason,
		arg.HumanComment,
	)
	return err
}
