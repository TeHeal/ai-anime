// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: provider_usages.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProviderUsage = `-- name: CreateProviderUsage :one
INSERT INTO provider_usages (project_id, user_id, provider, model, capability, input_tokens, output_tokens,
    image_count, video_seconds, audio_seconds, cost_cents, task_id, metadata_json)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, created_at, project_id, user_id, provider, model, capability, input_tokens, output_tokens, image_count, video_seconds, audio_seconds, cost_cents, task_id, metadata_json
`

type CreateProviderUsageParams struct {
	ProjectID    pgtype.UUID `json:"project_id"`
	UserID       pgtype.UUID `json:"user_id"`
	Provider     string      `json:"provider"`
	Model        string      `json:"model"`
	Capability   string      `json:"capability"`
	InputTokens  int32       `json:"input_tokens"`
	OutputTokens int32       `json:"output_tokens"`
	ImageCount   int32       `json:"image_count"`
	VideoSeconds int32       `json:"video_seconds"`
	AudioSeconds int32       `json:"audio_seconds"`
	CostCents    int32       `json:"cost_cents"`
	TaskID       pgtype.Text `json:"task_id"`
	MetadataJson []byte      `json:"metadata_json"`
}

func (q *Queries) CreateProviderUsage(ctx context.Context, arg CreateProviderUsageParams) (ProviderUsage, error) {
	row := q.db.QueryRow(ctx, createProviderUsage,
		arg.ProjectID,
		arg.UserID,
		arg.Provider,
		arg.Model,
		arg.Capability,
		arg.InputTokens,
		arg.OutputTokens,
		arg.ImageCount,
		arg.VideoSeconds,
		arg.AudioSeconds,
		arg.CostCents,
		arg.TaskID,
		arg.MetadataJson,
	)
	var i ProviderUsage
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ProjectID,
		&i.UserID,
		&i.Provider,
		&i.Model,
		&i.Capability,
		&i.InputTokens,
		&i.OutputTokens,
		&i.ImageCount,
		&i.VideoSeconds,
		&i.AudioSeconds,
		&i.CostCents,
		&i.TaskID,
		&i.MetadataJson,
	)
	return i, err
}

const listRecentUsages = `-- name: ListRecentUsages :many
SELECT id, created_at, project_id, user_id, provider, model, capability, input_tokens, output_tokens, image_count, video_seconds, audio_seconds, cost_cents, task_id, metadata_json FROM provider_usages WHERE project_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListRecentUsagesParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListRecentUsages(ctx context.Context, arg ListRecentUsagesParams) ([]ProviderUsage, error) {
	rows, err := q.db.Query(ctx, listRecentUsages, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProviderUsage{}
	for rows.Next() {
		var i ProviderUsage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ProjectID,
			&i.UserID,
			&i.Provider,
			&i.Model,
			&i.Capability,
			&i.InputTokens,
			&i.OutputTokens,
			&i.ImageCount,
			&i.VideoSeconds,
			&i.AudioSeconds,
			&i.CostCents,
			&i.TaskID,
			&i.MetadataJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumUsageByProject = `-- name: SumUsageByProject :one
SELECT COALESCE(SUM(input_tokens),0)::bigint AS total_input_tokens,
       COALESCE(SUM(output_tokens),0)::bigint AS total_output_tokens,
       COALESCE(SUM(image_count),0)::bigint AS total_images,
       COALESCE(SUM(video_seconds),0)::bigint AS total_video_seconds,
       COALESCE(SUM(cost_cents),0)::bigint AS total_cost_cents
FROM provider_usages WHERE project_id = $1
`

type SumUsageByProjectRow struct {
	TotalInputTokens  int64 `json:"total_input_tokens"`
	TotalOutputTokens int64 `json:"total_output_tokens"`
	TotalImages       int64 `json:"total_images"`
	TotalVideoSeconds int64 `json:"total_video_seconds"`
	TotalCostCents    int64 `json:"total_cost_cents"`
}

func (q *Queries) SumUsageByProject(ctx context.Context, projectID pgtype.UUID) (SumUsageByProjectRow, error) {
	row := q.db.QueryRow(ctx, sumUsageByProject, projectID)
	var i SumUsageByProjectRow
	err := row.Scan(
		&i.TotalInputTokens,
		&i.TotalOutputTokens,
		&i.TotalImages,
		&i.TotalVideoSeconds,
		&i.TotalCostCents,
	)
	return i, err
}

const sumUsageByProjectAndProvider = `-- name: SumUsageByProjectAndProvider :many
SELECT provider, model,
       COALESCE(SUM(input_tokens),0)::bigint AS total_input_tokens,
       COALESCE(SUM(output_tokens),0)::bigint AS total_output_tokens,
       COALESCE(SUM(cost_cents),0)::bigint AS total_cost_cents
FROM provider_usages WHERE project_id = $1
GROUP BY provider, model ORDER BY total_cost_cents DESC
`

type SumUsageByProjectAndProviderRow struct {
	Provider          string `json:"provider"`
	Model             string `json:"model"`
	TotalInputTokens  int64  `json:"total_input_tokens"`
	TotalOutputTokens int64  `json:"total_output_tokens"`
	TotalCostCents    int64  `json:"total_cost_cents"`
}

func (q *Queries) SumUsageByProjectAndProvider(ctx context.Context, projectID pgtype.UUID) ([]SumUsageByProjectAndProviderRow, error) {
	rows, err := q.db.Query(ctx, sumUsageByProjectAndProvider, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SumUsageByProjectAndProviderRow{}
	for rows.Next() {
		var i SumUsageByProjectAndProviderRow
		if err := rows.Scan(
			&i.Provider,
			&i.Model,
			&i.TotalInputTokens,
			&i.TotalOutputTokens,
			&i.TotalCostCents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
