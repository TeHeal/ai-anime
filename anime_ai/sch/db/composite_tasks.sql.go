// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: composite_tasks.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompositeTask = `-- name: CreateCompositeTask :one
INSERT INTO composite_tasks (project_id, episode_id, status, timeline_json, audio_tracks_json,
    subtitle_tracks_json, output_format, resolution, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, created_at, updated_at, project_id, episode_id, status, timeline_json, audio_tracks_json, subtitle_tracks_json, output_url, output_format, resolution, duration, progress, error_message, created_by, started_at, finished_at
`

type CreateCompositeTaskParams struct {
	ProjectID          pgtype.UUID `json:"project_id"`
	EpisodeID          pgtype.UUID `json:"episode_id"`
	Status             string      `json:"status"`
	TimelineJson       []byte      `json:"timeline_json"`
	AudioTracksJson    []byte      `json:"audio_tracks_json"`
	SubtitleTracksJson []byte      `json:"subtitle_tracks_json"`
	OutputFormat       pgtype.Text `json:"output_format"`
	Resolution         pgtype.Text `json:"resolution"`
	CreatedBy          pgtype.UUID `json:"created_by"`
}

func (q *Queries) CreateCompositeTask(ctx context.Context, arg CreateCompositeTaskParams) (CompositeTask, error) {
	row := q.db.QueryRow(ctx, createCompositeTask,
		arg.ProjectID,
		arg.EpisodeID,
		arg.Status,
		arg.TimelineJson,
		arg.AudioTracksJson,
		arg.SubtitleTracksJson,
		arg.OutputFormat,
		arg.Resolution,
		arg.CreatedBy,
	)
	var i CompositeTask
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.EpisodeID,
		&i.Status,
		&i.TimelineJson,
		&i.AudioTracksJson,
		&i.SubtitleTracksJson,
		&i.OutputUrl,
		&i.OutputFormat,
		&i.Resolution,
		&i.Duration,
		&i.Progress,
		&i.ErrorMessage,
		&i.CreatedBy,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const getCompositeTask = `-- name: GetCompositeTask :one
SELECT id, created_at, updated_at, project_id, episode_id, status, timeline_json, audio_tracks_json, subtitle_tracks_json, output_url, output_format, resolution, duration, progress, error_message, created_by, started_at, finished_at FROM composite_tasks WHERE id = $1
`

func (q *Queries) GetCompositeTask(ctx context.Context, id pgtype.UUID) (CompositeTask, error) {
	row := q.db.QueryRow(ctx, getCompositeTask, id)
	var i CompositeTask
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.EpisodeID,
		&i.Status,
		&i.TimelineJson,
		&i.AudioTracksJson,
		&i.SubtitleTracksJson,
		&i.OutputUrl,
		&i.OutputFormat,
		&i.Resolution,
		&i.Duration,
		&i.Progress,
		&i.ErrorMessage,
		&i.CreatedBy,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const listCompositeTasksByEpisode = `-- name: ListCompositeTasksByEpisode :many
SELECT id, created_at, updated_at, project_id, episode_id, status, timeline_json, audio_tracks_json, subtitle_tracks_json, output_url, output_format, resolution, duration, progress, error_message, created_by, started_at, finished_at FROM composite_tasks WHERE episode_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListCompositeTasksByEpisode(ctx context.Context, episodeID pgtype.UUID) ([]CompositeTask, error) {
	rows, err := q.db.Query(ctx, listCompositeTasksByEpisode, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CompositeTask{}
	for rows.Next() {
		var i CompositeTask
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.EpisodeID,
			&i.Status,
			&i.TimelineJson,
			&i.AudioTracksJson,
			&i.SubtitleTracksJson,
			&i.OutputUrl,
			&i.OutputFormat,
			&i.Resolution,
			&i.Duration,
			&i.Progress,
			&i.ErrorMessage,
			&i.CreatedBy,
			&i.StartedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCompositeTasksByProject = `-- name: ListCompositeTasksByProject :many
SELECT id, created_at, updated_at, project_id, episode_id, status, timeline_json, audio_tracks_json, subtitle_tracks_json, output_url, output_format, resolution, duration, progress, error_message, created_by, started_at, finished_at FROM composite_tasks WHERE project_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListCompositeTasksByProject(ctx context.Context, projectID pgtype.UUID) ([]CompositeTask, error) {
	rows, err := q.db.Query(ctx, listCompositeTasksByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CompositeTask{}
	for rows.Next() {
		var i CompositeTask
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.EpisodeID,
			&i.Status,
			&i.TimelineJson,
			&i.AudioTracksJson,
			&i.SubtitleTracksJson,
			&i.OutputUrl,
			&i.OutputFormat,
			&i.Resolution,
			&i.Duration,
			&i.Progress,
			&i.ErrorMessage,
			&i.CreatedBy,
			&i.StartedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startCompositeTask = `-- name: StartCompositeTask :exec
UPDATE composite_tasks SET status = 'exporting', started_at = now(), progress = 0
WHERE id = $1
`

func (q *Queries) StartCompositeTask(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, startCompositeTask, id)
	return err
}

const updateCompositeTaskOutput = `-- name: UpdateCompositeTaskOutput :exec
UPDATE composite_tasks SET status = 'done', output_url = $2, duration = $3, progress = 100, finished_at = now()
WHERE id = $1
`

type UpdateCompositeTaskOutputParams struct {
	ID        pgtype.UUID `json:"id"`
	OutputUrl pgtype.Text `json:"output_url"`
	Duration  int32       `json:"duration"`
}

func (q *Queries) UpdateCompositeTaskOutput(ctx context.Context, arg UpdateCompositeTaskOutputParams) error {
	_, err := q.db.Exec(ctx, updateCompositeTaskOutput, arg.ID, arg.OutputUrl, arg.Duration)
	return err
}

const updateCompositeTaskStatus = `-- name: UpdateCompositeTaskStatus :exec
UPDATE composite_tasks SET status = $2, progress = $3, error_message = $4
WHERE id = $1
`

type UpdateCompositeTaskStatusParams struct {
	ID           pgtype.UUID `json:"id"`
	Status       string      `json:"status"`
	Progress     int32       `json:"progress"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) UpdateCompositeTaskStatus(ctx context.Context, arg UpdateCompositeTaskStatusParams) error {
	_, err := q.db.Exec(ctx, updateCompositeTaskStatus,
		arg.ID,
		arg.Status,
		arg.Progress,
		arg.ErrorMessage,
	)
	return err
}

const updateCompositeTaskTimeline = `-- name: UpdateCompositeTaskTimeline :exec
UPDATE composite_tasks SET timeline_json = $2, audio_tracks_json = $3, subtitle_tracks_json = $4
WHERE id = $1
`

type UpdateCompositeTaskTimelineParams struct {
	ID                 pgtype.UUID `json:"id"`
	TimelineJson       []byte      `json:"timeline_json"`
	AudioTracksJson    []byte      `json:"audio_tracks_json"`
	SubtitleTracksJson []byte      `json:"subtitle_tracks_json"`
}

func (q *Queries) UpdateCompositeTaskTimeline(ctx context.Context, arg UpdateCompositeTaskTimelineParams) error {
	_, err := q.db.Exec(ctx, updateCompositeTaskTimeline,
		arg.ID,
		arg.TimelineJson,
		arg.AudioTracksJson,
		arg.SubtitleTracksJson,
	)
	return err
}
