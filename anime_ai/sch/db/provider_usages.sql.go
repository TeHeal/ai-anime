// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: provider_usages.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProviderUsage = `-- name: CreateProviderUsage :one
INSERT INTO provider_usages (
    project_id, user_id, org_id, provider, model, service_type,
    token_count, image_count, video_seconds, cost_cents, meta_json
)
VALUES (
    $1, $2, $3,
    $4, $5, $6,
    COALESCE($7, 0),
    COALESCE($8, 0),
    COALESCE($9, 0),
    COALESCE($10, 0),
    COALESCE($11, '{}')
)
RETURNING id, created_at, project_id, user_id, org_id, provider, model, service_type, token_count, image_count, video_seconds, cost_cents, meta_json
`

type CreateProviderUsageParams struct {
	ProjectID    pgtype.UUID `json:"project_id"`
	UserID       pgtype.UUID `json:"user_id"`
	OrgID        pgtype.UUID `json:"org_id"`
	Provider     string      `json:"provider"`
	Model        string      `json:"model"`
	ServiceType  string      `json:"service_type"`
	TokenCount   interface{} `json:"token_count"`
	ImageCount   interface{} `json:"image_count"`
	VideoSeconds interface{} `json:"video_seconds"`
	CostCents    interface{} `json:"cost_cents"`
	MetaJson     interface{} `json:"meta_json"`
}

func (q *Queries) CreateProviderUsage(ctx context.Context, arg CreateProviderUsageParams) (ProviderUsage, error) {
	row := q.db.QueryRow(ctx, createProviderUsage,
		arg.ProjectID,
		arg.UserID,
		arg.OrgID,
		arg.Provider,
		arg.Model,
		arg.ServiceType,
		arg.TokenCount,
		arg.ImageCount,
		arg.VideoSeconds,
		arg.CostCents,
		arg.MetaJson,
	)
	var i ProviderUsage
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ProjectID,
		&i.UserID,
		&i.OrgID,
		&i.Provider,
		&i.Model,
		&i.ServiceType,
		&i.TokenCount,
		&i.ImageCount,
		&i.VideoSeconds,
		&i.CostCents,
		&i.MetaJson,
	)
	return i, err
}

const listProviderUsages = `-- name: ListProviderUsages :many

SELECT id, created_at, project_id, user_id, org_id, provider, model, service_type, token_count, image_count, video_seconds, cost_cents, meta_json FROM provider_usages
WHERE
    ($1::uuid IS NULL OR project_id = $1)
    AND ($2::uuid IS NULL OR user_id = $2)
    AND ($3::timestamptz IS NULL OR created_at >= $3)
    AND ($4::timestamptz IS NULL OR created_at <= $4)
ORDER BY created_at DESC
LIMIT $6 OFFSET $5
`

type ListProviderUsagesParams struct {
	ProjectID pgtype.UUID        `json:"project_id"`
	UserID    pgtype.UUID        `json:"user_id"`
	StartAt   pgtype.Timestamptz `json:"start_at"`
	EndAt     pgtype.Timestamptz `json:"end_at"`
	Offset    int32              `json:"offset"`
	Limit     int32              `json:"limit"`
}

// AI 用量统计（README 8.3 AI 成本控制）
func (q *Queries) ListProviderUsages(ctx context.Context, arg ListProviderUsagesParams) ([]ProviderUsage, error) {
	rows, err := q.db.Query(ctx, listProviderUsages,
		arg.ProjectID,
		arg.UserID,
		arg.StartAt,
		arg.EndAt,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProviderUsage{}
	for rows.Next() {
		var i ProviderUsage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ProjectID,
			&i.UserID,
			&i.OrgID,
			&i.Provider,
			&i.Model,
			&i.ServiceType,
			&i.TokenCount,
			&i.ImageCount,
			&i.VideoSeconds,
			&i.CostCents,
			&i.MetaJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
