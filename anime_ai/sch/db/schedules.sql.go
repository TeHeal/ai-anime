// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: schedules.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSchedule = `-- name: CreateSchedule :one
INSERT INTO schedules (project_id, name, cron_expr, task_type, task_params_json, enabled, next_run_at, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, created_at, updated_at, deleted_at, project_id, name, cron_expr, task_type, task_params_json, enabled, last_run_at, next_run_at, created_by
`

type CreateScheduleParams struct {
	ProjectID      pgtype.UUID        `json:"project_id"`
	Name           string             `json:"name"`
	CronExpr       string             `json:"cron_expr"`
	TaskType       string             `json:"task_type"`
	TaskParamsJson []byte             `json:"task_params_json"`
	Enabled        bool               `json:"enabled"`
	NextRunAt      pgtype.Timestamptz `json:"next_run_at"`
	CreatedBy      pgtype.UUID        `json:"created_by"`
}

func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, createSchedule,
		arg.ProjectID,
		arg.Name,
		arg.CronExpr,
		arg.TaskType,
		arg.TaskParamsJson,
		arg.Enabled,
		arg.NextRunAt,
		arg.CreatedBy,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Name,
		&i.CronExpr,
		&i.TaskType,
		&i.TaskParamsJson,
		&i.Enabled,
		&i.LastRunAt,
		&i.NextRunAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteSchedule = `-- name: DeleteSchedule :exec
UPDATE schedules SET deleted_at = now() WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteSchedule(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSchedule, id)
	return err
}

const getSchedule = `-- name: GetSchedule :one
SELECT id, created_at, updated_at, deleted_at, project_id, name, cron_expr, task_type, task_params_json, enabled, last_run_at, next_run_at, created_by FROM schedules WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetSchedule(ctx context.Context, id pgtype.UUID) (Schedule, error) {
	row := q.db.QueryRow(ctx, getSchedule, id)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Name,
		&i.CronExpr,
		&i.TaskType,
		&i.TaskParamsJson,
		&i.Enabled,
		&i.LastRunAt,
		&i.NextRunAt,
		&i.CreatedBy,
	)
	return i, err
}

const listDueSchedules = `-- name: ListDueSchedules :many
SELECT id, created_at, updated_at, deleted_at, project_id, name, cron_expr, task_type, task_params_json, enabled, last_run_at, next_run_at, created_by FROM schedules WHERE enabled = true AND deleted_at IS NULL AND next_run_at <= now()
ORDER BY next_run_at
`

func (q *Queries) ListDueSchedules(ctx context.Context) ([]Schedule, error) {
	rows, err := q.db.Query(ctx, listDueSchedules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Schedule{}
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.Name,
			&i.CronExpr,
			&i.TaskType,
			&i.TaskParamsJson,
			&i.Enabled,
			&i.LastRunAt,
			&i.NextRunAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchedulesByProject = `-- name: ListSchedulesByProject :many
SELECT id, created_at, updated_at, deleted_at, project_id, name, cron_expr, task_type, task_params_json, enabled, last_run_at, next_run_at, created_by FROM schedules WHERE project_id = $1 AND deleted_at IS NULL ORDER BY created_at DESC
`

func (q *Queries) ListSchedulesByProject(ctx context.Context, projectID pgtype.UUID) ([]Schedule, error) {
	rows, err := q.db.Query(ctx, listSchedulesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Schedule{}
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.Name,
			&i.CronExpr,
			&i.TaskType,
			&i.TaskParamsJson,
			&i.Enabled,
			&i.LastRunAt,
			&i.NextRunAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSchedule = `-- name: UpdateSchedule :exec
UPDATE schedules SET name = $2, cron_expr = $3, task_type = $4, task_params_json = $5, enabled = $6
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateScheduleParams struct {
	ID             pgtype.UUID `json:"id"`
	Name           string      `json:"name"`
	CronExpr       string      `json:"cron_expr"`
	TaskType       string      `json:"task_type"`
	TaskParamsJson []byte      `json:"task_params_json"`
	Enabled        bool        `json:"enabled"`
}

func (q *Queries) UpdateSchedule(ctx context.Context, arg UpdateScheduleParams) error {
	_, err := q.db.Exec(ctx, updateSchedule,
		arg.ID,
		arg.Name,
		arg.CronExpr,
		arg.TaskType,
		arg.TaskParamsJson,
		arg.Enabled,
	)
	return err
}

const updateScheduleLastRun = `-- name: UpdateScheduleLastRun :exec
UPDATE schedules SET last_run_at = now(), next_run_at = $2
WHERE id = $1
`

type UpdateScheduleLastRunParams struct {
	ID        pgtype.UUID        `json:"id"`
	NextRunAt pgtype.Timestamptz `json:"next_run_at"`
}

func (q *Queries) UpdateScheduleLastRun(ctx context.Context, arg UpdateScheduleLastRunParams) error {
	_, err := q.db.Exec(ctx, updateScheduleLastRun, arg.ID, arg.NextRunAt)
	return err
}
