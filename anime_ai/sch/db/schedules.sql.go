// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: schedules.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSchedule = `-- name: CreateSchedule :one

INSERT INTO schedules (project_id, user_id, name, cron_expr, action, config_json, enabled, last_run_at, next_run_at)
VALUES (
    $1, $2,
    COALESCE($3, ''),
    $4,
    COALESCE($5, 'pipeline'),
    COALESCE($6, '{}'),
    COALESCE($7, true),
    $8,
    $9
)
RETURNING id, created_at, updated_at, deleted_at, project_id, user_id, name, cron_expr, action, config_json, enabled, last_run_at, next_run_at
`

type CreateScheduleParams struct {
	ProjectID  pgtype.UUID        `json:"project_id"`
	UserID     pgtype.UUID        `json:"user_id"`
	Name       interface{}        `json:"name"`
	CronExpr   string             `json:"cron_expr"`
	Action     interface{}        `json:"action"`
	ConfigJson interface{}        `json:"config_json"`
	Enabled    interface{}        `json:"enabled"`
	LastRunAt  pgtype.Timestamptz `json:"last_run_at"`
	NextRunAt  pgtype.Timestamptz `json:"next_run_at"`
}

// 定时任务 CRUD（README 2.1 定时任务、按计划触发流水线）
func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, createSchedule,
		arg.ProjectID,
		arg.UserID,
		arg.Name,
		arg.CronExpr,
		arg.Action,
		arg.ConfigJson,
		arg.Enabled,
		arg.LastRunAt,
		arg.NextRunAt,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.UserID,
		&i.Name,
		&i.CronExpr,
		&i.Action,
		&i.ConfigJson,
		&i.Enabled,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return i, err
}

const deleteSchedule = `-- name: DeleteSchedule :exec
UPDATE schedules SET deleted_at = now() WHERE id = $1
`

func (q *Queries) DeleteSchedule(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSchedule, id)
	return err
}

const getScheduleByID = `-- name: GetScheduleByID :one
SELECT id, created_at, updated_at, deleted_at, project_id, user_id, name, cron_expr, action, config_json, enabled, last_run_at, next_run_at FROM schedules
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetScheduleByID(ctx context.Context, id pgtype.UUID) (Schedule, error) {
	row := q.db.QueryRow(ctx, getScheduleByID, id)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.UserID,
		&i.Name,
		&i.CronExpr,
		&i.Action,
		&i.ConfigJson,
		&i.Enabled,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return i, err
}

const listDueSchedules = `-- name: ListDueSchedules :many
SELECT id, created_at, updated_at, deleted_at, project_id, user_id, name, cron_expr, action, config_json, enabled, last_run_at, next_run_at FROM schedules
WHERE next_run_at <= now() AND enabled = true AND deleted_at IS NULL
ORDER BY next_run_at ASC
`

func (q *Queries) ListDueSchedules(ctx context.Context) ([]Schedule, error) {
	rows, err := q.db.Query(ctx, listDueSchedules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Schedule{}
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.UserID,
			&i.Name,
			&i.CronExpr,
			&i.Action,
			&i.ConfigJson,
			&i.Enabled,
			&i.LastRunAt,
			&i.NextRunAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchedulesByProject = `-- name: ListSchedulesByProject :many
SELECT id, created_at, updated_at, deleted_at, project_id, user_id, name, cron_expr, action, config_json, enabled, last_run_at, next_run_at FROM schedules
WHERE project_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListSchedulesByProject(ctx context.Context, projectID pgtype.UUID) ([]Schedule, error) {
	rows, err := q.db.Query(ctx, listSchedulesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Schedule{}
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.UserID,
			&i.Name,
			&i.CronExpr,
			&i.Action,
			&i.ConfigJson,
			&i.Enabled,
			&i.LastRunAt,
			&i.NextRunAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSchedule = `-- name: UpdateSchedule :one
UPDATE schedules
SET
    name = COALESCE($1, name),
    cron_expr = COALESCE($2, cron_expr),
    action = COALESCE($3, action),
    config_json = COALESCE($4, config_json),
    enabled = COALESCE($5, enabled),
    last_run_at = $6,
    next_run_at = $7
WHERE id = $8 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, project_id, user_id, name, cron_expr, action, config_json, enabled, last_run_at, next_run_at
`

type UpdateScheduleParams struct {
	Name       pgtype.Text        `json:"name"`
	CronExpr   pgtype.Text        `json:"cron_expr"`
	Action     pgtype.Text        `json:"action"`
	ConfigJson []byte             `json:"config_json"`
	Enabled    pgtype.Bool        `json:"enabled"`
	LastRunAt  pgtype.Timestamptz `json:"last_run_at"`
	NextRunAt  pgtype.Timestamptz `json:"next_run_at"`
	ID         pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateSchedule(ctx context.Context, arg UpdateScheduleParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, updateSchedule,
		arg.Name,
		arg.CronExpr,
		arg.Action,
		arg.ConfigJson,
		arg.Enabled,
		arg.LastRunAt,
		arg.NextRunAt,
		arg.ID,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.UserID,
		&i.Name,
		&i.CronExpr,
		&i.Action,
		&i.ConfigJson,
		&i.Enabled,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return i, err
}

const updateScheduleRunTimes = `-- name: UpdateScheduleRunTimes :exec
UPDATE schedules SET last_run_at = $1, next_run_at = $2
WHERE id = $3 AND deleted_at IS NULL
`

type UpdateScheduleRunTimesParams struct {
	LastRunAt pgtype.Timestamptz `json:"last_run_at"`
	NextRunAt pgtype.Timestamptz `json:"next_run_at"`
	ID        pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateScheduleRunTimes(ctx context.Context, arg UpdateScheduleRunTimesParams) error {
	_, err := q.db.Exec(ctx, updateScheduleRunTimes, arg.LastRunAt, arg.NextRunAt, arg.ID)
	return err
}
