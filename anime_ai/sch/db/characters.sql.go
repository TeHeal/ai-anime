// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: characters.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCharacter = `-- name: CreateCharacter :one

INSERT INTO characters (
    project_id, user_id, name, alias_json, appearance, style, style_override,
    personality, voice_hint, emotions, scenes, gender, age_group, voice_id, voice_name,
    image_url, reference_images_json, task_id, image_status, shared, status, source,
    variants_json, importance, consistency, role_type, tags_json, props_json,
    bio, bio_fragments_json, image_gen_override_json, version
)
VALUES (
    $1, $2, $3,
    COALESCE($4, '[]'), $5, $6,
    COALESCE($7, false), $8, $9,
    $10, $11, $12, $13,
    $14, $15, $16,
    COALESCE($17, '[]'), $18,
    COALESCE($19, 'none'), COALESCE($20, false),
    COALESCE($21, 'draft'), COALESCE($22, 'manual'),
    COALESCE($23, '[]'), $24, $25,
    $26, COALESCE($27, '[]'),
    COALESCE($28, '{}'), $29,
    COALESCE($30, '[]'),
    COALESCE($31, '{}'),
    COALESCE($32, 1)
)
RETURNING id, created_at, updated_at, deleted_at, project_id, user_id, name, alias_json, appearance, style, style_id, style_override, personality, voice_hint, emotions, scenes, gender, age_group, voice_id, voice_name, image_url, reference_images_json, task_id, image_status, shared, status, source, variants_json, importance, consistency, role_type, tags_json, props_json, bio, bio_fragments_json, image_gen_override_json, version
`

type CreateCharacterParams struct {
	ProjectID            pgtype.UUID `json:"project_id"`
	UserID               pgtype.UUID `json:"user_id"`
	Name                 string      `json:"name"`
	AliasJson            interface{} `json:"alias_json"`
	Appearance           pgtype.Text `json:"appearance"`
	Style                pgtype.Text `json:"style"`
	StyleOverride        interface{} `json:"style_override"`
	Personality          pgtype.Text `json:"personality"`
	VoiceHint            pgtype.Text `json:"voice_hint"`
	Emotions             pgtype.Text `json:"emotions"`
	Scenes               pgtype.Text `json:"scenes"`
	Gender               pgtype.Text `json:"gender"`
	AgeGroup             pgtype.Text `json:"age_group"`
	VoiceID              pgtype.Text `json:"voice_id"`
	VoiceName            pgtype.Text `json:"voice_name"`
	ImageUrl             pgtype.Text `json:"image_url"`
	ReferenceImagesJson  interface{} `json:"reference_images_json"`
	TaskID               pgtype.Text `json:"task_id"`
	ImageStatus          interface{} `json:"image_status"`
	Shared               interface{} `json:"shared"`
	Status               interface{} `json:"status"`
	Source               interface{} `json:"source"`
	VariantsJson         interface{} `json:"variants_json"`
	Importance           pgtype.Text `json:"importance"`
	Consistency          pgtype.Text `json:"consistency"`
	RoleType             pgtype.Text `json:"role_type"`
	TagsJson             interface{} `json:"tags_json"`
	PropsJson            interface{} `json:"props_json"`
	Bio                  pgtype.Text `json:"bio"`
	BioFragmentsJson     interface{} `json:"bio_fragments_json"`
	ImageGenOverrideJson interface{} `json:"image_gen_override_json"`
	Version              interface{} `json:"version"`
}

// 角色 CRUD（项目级）
func (q *Queries) CreateCharacter(ctx context.Context, arg CreateCharacterParams) (Character, error) {
	row := q.db.QueryRow(ctx, createCharacter,
		arg.ProjectID,
		arg.UserID,
		arg.Name,
		arg.AliasJson,
		arg.Appearance,
		arg.Style,
		arg.StyleOverride,
		arg.Personality,
		arg.VoiceHint,
		arg.Emotions,
		arg.Scenes,
		arg.Gender,
		arg.AgeGroup,
		arg.VoiceID,
		arg.VoiceName,
		arg.ImageUrl,
		arg.ReferenceImagesJson,
		arg.TaskID,
		arg.ImageStatus,
		arg.Shared,
		arg.Status,
		arg.Source,
		arg.VariantsJson,
		arg.Importance,
		arg.Consistency,
		arg.RoleType,
		arg.TagsJson,
		arg.PropsJson,
		arg.Bio,
		arg.BioFragmentsJson,
		arg.ImageGenOverrideJson,
		arg.Version,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.UserID,
		&i.Name,
		&i.AliasJson,
		&i.Appearance,
		&i.Style,
		&i.StyleID,
		&i.StyleOverride,
		&i.Personality,
		&i.VoiceHint,
		&i.Emotions,
		&i.Scenes,
		&i.Gender,
		&i.AgeGroup,
		&i.VoiceID,
		&i.VoiceName,
		&i.ImageUrl,
		&i.ReferenceImagesJson,
		&i.TaskID,
		&i.ImageStatus,
		&i.Shared,
		&i.Status,
		&i.Source,
		&i.VariantsJson,
		&i.Importance,
		&i.Consistency,
		&i.RoleType,
		&i.TagsJson,
		&i.PropsJson,
		&i.Bio,
		&i.BioFragmentsJson,
		&i.ImageGenOverrideJson,
		&i.Version,
	)
	return i, err
}

const getCharacterByID = `-- name: GetCharacterByID :one
SELECT id, created_at, updated_at, deleted_at, project_id, user_id, name, alias_json, appearance, style, style_id, style_override, personality, voice_hint, emotions, scenes, gender, age_group, voice_id, voice_name, image_url, reference_images_json, task_id, image_status, shared, status, source, variants_json, importance, consistency, role_type, tags_json, props_json, bio, bio_fragments_json, image_gen_override_json, version FROM characters
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetCharacterByID(ctx context.Context, id pgtype.UUID) (Character, error) {
	row := q.db.QueryRow(ctx, getCharacterByID, id)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.UserID,
		&i.Name,
		&i.AliasJson,
		&i.Appearance,
		&i.Style,
		&i.StyleID,
		&i.StyleOverride,
		&i.Personality,
		&i.VoiceHint,
		&i.Emotions,
		&i.Scenes,
		&i.Gender,
		&i.AgeGroup,
		&i.VoiceID,
		&i.VoiceName,
		&i.ImageUrl,
		&i.ReferenceImagesJson,
		&i.TaskID,
		&i.ImageStatus,
		&i.Shared,
		&i.Status,
		&i.Source,
		&i.VariantsJson,
		&i.Importance,
		&i.Consistency,
		&i.RoleType,
		&i.TagsJson,
		&i.PropsJson,
		&i.Bio,
		&i.BioFragmentsJson,
		&i.ImageGenOverrideJson,
		&i.Version,
	)
	return i, err
}

const getCharacterByNameAndProject = `-- name: GetCharacterByNameAndProject :one
SELECT id, created_at, updated_at, deleted_at, project_id, user_id, name, alias_json, appearance, style, style_id, style_override, personality, voice_hint, emotions, scenes, gender, age_group, voice_id, voice_name, image_url, reference_images_json, task_id, image_status, shared, status, source, variants_json, importance, consistency, role_type, tags_json, props_json, bio, bio_fragments_json, image_gen_override_json, version FROM characters
WHERE project_id = $1 AND name = $2 AND deleted_at IS NULL
`

type GetCharacterByNameAndProjectParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	Name      string      `json:"name"`
}

func (q *Queries) GetCharacterByNameAndProject(ctx context.Context, arg GetCharacterByNameAndProjectParams) (Character, error) {
	row := q.db.QueryRow(ctx, getCharacterByNameAndProject, arg.ProjectID, arg.Name)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.UserID,
		&i.Name,
		&i.AliasJson,
		&i.Appearance,
		&i.Style,
		&i.StyleID,
		&i.StyleOverride,
		&i.Personality,
		&i.VoiceHint,
		&i.Emotions,
		&i.Scenes,
		&i.Gender,
		&i.AgeGroup,
		&i.VoiceID,
		&i.VoiceName,
		&i.ImageUrl,
		&i.ReferenceImagesJson,
		&i.TaskID,
		&i.ImageStatus,
		&i.Shared,
		&i.Status,
		&i.Source,
		&i.VariantsJson,
		&i.Importance,
		&i.Consistency,
		&i.RoleType,
		&i.TagsJson,
		&i.PropsJson,
		&i.Bio,
		&i.BioFragmentsJson,
		&i.ImageGenOverrideJson,
		&i.Version,
	)
	return i, err
}

const listCharactersByProject = `-- name: ListCharactersByProject :many
SELECT id, created_at, updated_at, deleted_at, project_id, user_id, name, alias_json, appearance, style, style_id, style_override, personality, voice_hint, emotions, scenes, gender, age_group, voice_id, voice_name, image_url, reference_images_json, task_id, image_status, shared, status, source, variants_json, importance, consistency, role_type, tags_json, props_json, bio, bio_fragments_json, image_gen_override_json, version FROM characters
WHERE project_id = $1 AND deleted_at IS NULL
ORDER BY created_at ASC
`

func (q *Queries) ListCharactersByProject(ctx context.Context, projectID pgtype.UUID) ([]Character, error) {
	rows, err := q.db.Query(ctx, listCharactersByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Character{}
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.UserID,
			&i.Name,
			&i.AliasJson,
			&i.Appearance,
			&i.Style,
			&i.StyleID,
			&i.StyleOverride,
			&i.Personality,
			&i.VoiceHint,
			&i.Emotions,
			&i.Scenes,
			&i.Gender,
			&i.AgeGroup,
			&i.VoiceID,
			&i.VoiceName,
			&i.ImageUrl,
			&i.ReferenceImagesJson,
			&i.TaskID,
			&i.ImageStatus,
			&i.Shared,
			&i.Status,
			&i.Source,
			&i.VariantsJson,
			&i.Importance,
			&i.Consistency,
			&i.RoleType,
			&i.TagsJson,
			&i.PropsJson,
			&i.Bio,
			&i.BioFragmentsJson,
			&i.ImageGenOverrideJson,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharactersByUser = `-- name: ListCharactersByUser :many
SELECT id, created_at, updated_at, deleted_at, project_id, user_id, name, alias_json, appearance, style, style_id, style_override, personality, voice_hint, emotions, scenes, gender, age_group, voice_id, voice_name, image_url, reference_images_json, task_id, image_status, shared, status, source, variants_json, importance, consistency, role_type, tags_json, props_json, bio, bio_fragments_json, image_gen_override_json, version FROM characters
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY updated_at DESC
`

func (q *Queries) ListCharactersByUser(ctx context.Context, userID pgtype.UUID) ([]Character, error) {
	rows, err := q.db.Query(ctx, listCharactersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Character{}
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.UserID,
			&i.Name,
			&i.AliasJson,
			&i.Appearance,
			&i.Style,
			&i.StyleID,
			&i.StyleOverride,
			&i.Personality,
			&i.VoiceHint,
			&i.Emotions,
			&i.Scenes,
			&i.Gender,
			&i.AgeGroup,
			&i.VoiceID,
			&i.VoiceName,
			&i.ImageUrl,
			&i.ReferenceImagesJson,
			&i.TaskID,
			&i.ImageStatus,
			&i.Shared,
			&i.Status,
			&i.Source,
			&i.VariantsJson,
			&i.Importance,
			&i.Consistency,
			&i.RoleType,
			&i.TagsJson,
			&i.PropsJson,
			&i.Bio,
			&i.BioFragmentsJson,
			&i.ImageGenOverrideJson,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharactersByUserWithShared = `-- name: ListCharactersByUserWithShared :many
SELECT id, created_at, updated_at, deleted_at, project_id, user_id, name, alias_json, appearance, style, style_id, style_override, personality, voice_hint, emotions, scenes, gender, age_group, voice_id, voice_name, image_url, reference_images_json, task_id, image_status, shared, status, source, variants_json, importance, consistency, role_type, tags_json, props_json, bio, bio_fragments_json, image_gen_override_json, version FROM characters
WHERE (user_id = $1 OR shared = true) AND deleted_at IS NULL
ORDER BY updated_at DESC
`

func (q *Queries) ListCharactersByUserWithShared(ctx context.Context, userID pgtype.UUID) ([]Character, error) {
	rows, err := q.db.Query(ctx, listCharactersByUserWithShared, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Character{}
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.UserID,
			&i.Name,
			&i.AliasJson,
			&i.Appearance,
			&i.Style,
			&i.StyleID,
			&i.StyleOverride,
			&i.Personality,
			&i.VoiceHint,
			&i.Emotions,
			&i.Scenes,
			&i.Gender,
			&i.AgeGroup,
			&i.VoiceID,
			&i.VoiceName,
			&i.ImageUrl,
			&i.ReferenceImagesJson,
			&i.TaskID,
			&i.ImageStatus,
			&i.Shared,
			&i.Status,
			&i.Source,
			&i.VariantsJson,
			&i.Importance,
			&i.Consistency,
			&i.RoleType,
			&i.TagsJson,
			&i.PropsJson,
			&i.Bio,
			&i.BioFragmentsJson,
			&i.ImageGenOverrideJson,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteCharacter = `-- name: SoftDeleteCharacter :exec
UPDATE characters SET deleted_at = now() WHERE id = $1
`

func (q *Queries) SoftDeleteCharacter(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteCharacter, id)
	return err
}

const updateCharacter = `-- name: UpdateCharacter :one
UPDATE characters
SET
    name = COALESCE($1, name),
    alias_json = COALESCE($2, alias_json),
    appearance = COALESCE($3, appearance),
    style = COALESCE($4, style),
    style_override = COALESCE($5, style_override),
    personality = COALESCE($6, personality),
    voice_hint = COALESCE($7, voice_hint),
    emotions = COALESCE($8, emotions),
    scenes = COALESCE($9, scenes),
    gender = COALESCE($10, gender),
    age_group = COALESCE($11, age_group),
    voice_id = COALESCE($12, voice_id),
    voice_name = COALESCE($13, voice_name),
    image_url = COALESCE($14, image_url),
    reference_images_json = COALESCE($15, reference_images_json),
    task_id = COALESCE($16, task_id),
    image_status = COALESCE($17, image_status),
    shared = COALESCE($18, shared),
    status = COALESCE($19, status),
    source = COALESCE($20, source),
    variants_json = COALESCE($21, variants_json),
    importance = COALESCE($22, importance),
    consistency = COALESCE($23, consistency),
    role_type = COALESCE($24, role_type),
    tags_json = COALESCE($25, tags_json),
    props_json = COALESCE($26, props_json),
    bio = COALESCE($27, bio),
    bio_fragments_json = COALESCE($28, bio_fragments_json),
    image_gen_override_json = COALESCE($29, image_gen_override_json),
    version = COALESCE($30, version)
WHERE id = $31 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, project_id, user_id, name, alias_json, appearance, style, style_id, style_override, personality, voice_hint, emotions, scenes, gender, age_group, voice_id, voice_name, image_url, reference_images_json, task_id, image_status, shared, status, source, variants_json, importance, consistency, role_type, tags_json, props_json, bio, bio_fragments_json, image_gen_override_json, version
`

type UpdateCharacterParams struct {
	Name                 pgtype.Text `json:"name"`
	AliasJson            []byte      `json:"alias_json"`
	Appearance           pgtype.Text `json:"appearance"`
	Style                pgtype.Text `json:"style"`
	StyleOverride        pgtype.Bool `json:"style_override"`
	Personality          pgtype.Text `json:"personality"`
	VoiceHint            pgtype.Text `json:"voice_hint"`
	Emotions             pgtype.Text `json:"emotions"`
	Scenes               pgtype.Text `json:"scenes"`
	Gender               pgtype.Text `json:"gender"`
	AgeGroup             pgtype.Text `json:"age_group"`
	VoiceID              pgtype.Text `json:"voice_id"`
	VoiceName            pgtype.Text `json:"voice_name"`
	ImageUrl             pgtype.Text `json:"image_url"`
	ReferenceImagesJson  []byte      `json:"reference_images_json"`
	TaskID               pgtype.Text `json:"task_id"`
	ImageStatus          pgtype.Text `json:"image_status"`
	Shared               pgtype.Bool `json:"shared"`
	Status               pgtype.Text `json:"status"`
	Source               pgtype.Text `json:"source"`
	VariantsJson         []byte      `json:"variants_json"`
	Importance           pgtype.Text `json:"importance"`
	Consistency          pgtype.Text `json:"consistency"`
	RoleType             pgtype.Text `json:"role_type"`
	TagsJson             []byte      `json:"tags_json"`
	PropsJson            []byte      `json:"props_json"`
	Bio                  pgtype.Text `json:"bio"`
	BioFragmentsJson     []byte      `json:"bio_fragments_json"`
	ImageGenOverrideJson []byte      `json:"image_gen_override_json"`
	Version              pgtype.Int4 `json:"version"`
	ID                   pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateCharacter(ctx context.Context, arg UpdateCharacterParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateCharacter,
		arg.Name,
		arg.AliasJson,
		arg.Appearance,
		arg.Style,
		arg.StyleOverride,
		arg.Personality,
		arg.VoiceHint,
		arg.Emotions,
		arg.Scenes,
		arg.Gender,
		arg.AgeGroup,
		arg.VoiceID,
		arg.VoiceName,
		arg.ImageUrl,
		arg.ReferenceImagesJson,
		arg.TaskID,
		arg.ImageStatus,
		arg.Shared,
		arg.Status,
		arg.Source,
		arg.VariantsJson,
		arg.Importance,
		arg.Consistency,
		arg.RoleType,
		arg.TagsJson,
		arg.PropsJson,
		arg.Bio,
		arg.BioFragmentsJson,
		arg.ImageGenOverrideJson,
		arg.Version,
		arg.ID,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.UserID,
		&i.Name,
		&i.AliasJson,
		&i.Appearance,
		&i.Style,
		&i.StyleID,
		&i.StyleOverride,
		&i.Personality,
		&i.VoiceHint,
		&i.Emotions,
		&i.Scenes,
		&i.Gender,
		&i.AgeGroup,
		&i.VoiceID,
		&i.VoiceName,
		&i.ImageUrl,
		&i.ReferenceImagesJson,
		&i.TaskID,
		&i.ImageStatus,
		&i.Shared,
		&i.Status,
		&i.Source,
		&i.VariantsJson,
		&i.Importance,
		&i.Consistency,
		&i.RoleType,
		&i.TagsJson,
		&i.PropsJson,
		&i.Bio,
		&i.BioFragmentsJson,
		&i.ImageGenOverrideJson,
		&i.Version,
	)
	return i, err
}

const updateCharacterImage = `-- name: UpdateCharacterImage :one
UPDATE characters
SET image_url = COALESCE($1, image_url),
    task_id = COALESCE($2, task_id),
    image_status = COALESCE($3, image_status)
WHERE id = $4 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, project_id, user_id, name, alias_json, appearance, style, style_id, style_override, personality, voice_hint, emotions, scenes, gender, age_group, voice_id, voice_name, image_url, reference_images_json, task_id, image_status, shared, status, source, variants_json, importance, consistency, role_type, tags_json, props_json, bio, bio_fragments_json, image_gen_override_json, version
`

type UpdateCharacterImageParams struct {
	ImageUrl    pgtype.Text `json:"image_url"`
	TaskID      pgtype.Text `json:"task_id"`
	ImageStatus pgtype.Text `json:"image_status"`
	ID          pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateCharacterImage(ctx context.Context, arg UpdateCharacterImageParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateCharacterImage,
		arg.ImageUrl,
		arg.TaskID,
		arg.ImageStatus,
		arg.ID,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.UserID,
		&i.Name,
		&i.AliasJson,
		&i.Appearance,
		&i.Style,
		&i.StyleID,
		&i.StyleOverride,
		&i.Personality,
		&i.VoiceHint,
		&i.Emotions,
		&i.Scenes,
		&i.Gender,
		&i.AgeGroup,
		&i.VoiceID,
		&i.VoiceName,
		&i.ImageUrl,
		&i.ReferenceImagesJson,
		&i.TaskID,
		&i.ImageStatus,
		&i.Shared,
		&i.Status,
		&i.Source,
		&i.VariantsJson,
		&i.Importance,
		&i.Consistency,
		&i.RoleType,
		&i.TagsJson,
		&i.PropsJson,
		&i.Bio,
		&i.BioFragmentsJson,
		&i.ImageGenOverrideJson,
		&i.Version,
	)
	return i, err
}
