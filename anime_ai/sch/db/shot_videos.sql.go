// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: shot_videos.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createShotVideo = `-- name: CreateShotVideo :one

INSERT INTO shot_videos (
    shot_id, project_id, shot_image_id, video_url, task_id, status, duration,
    provider, model, params_json, version,
    review_status, review_comment, reviewed_at, reviewed_by
)
VALUES (
    $1, $2, $3,
    $4, $5, COALESCE($6, 'pending'),
    COALESCE($7, 0), $8, $9,
    COALESCE($10, '{}'), COALESCE($11, 1),
    $12, $13,
    $14, $15
)
RETURNING id, created_at, updated_at, deleted_at, shot_id, project_id, shot_image_id, video_url, task_id, status, duration, provider, model, params_json, version, review_status, review_comment, reviewed_at, reviewed_by
`

type CreateShotVideoParams struct {
	ShotID        pgtype.UUID        `json:"shot_id"`
	ProjectID     pgtype.UUID        `json:"project_id"`
	ShotImageID   pgtype.UUID        `json:"shot_image_id"`
	VideoUrl      string             `json:"video_url"`
	TaskID        pgtype.Text        `json:"task_id"`
	Status        interface{}        `json:"status"`
	Duration      interface{}        `json:"duration"`
	Provider      pgtype.Text        `json:"provider"`
	Model         pgtype.Text        `json:"model"`
	ParamsJson    interface{}        `json:"params_json"`
	Version       interface{}        `json:"version"`
	ReviewStatus  pgtype.Text        `json:"review_status"`
	ReviewComment pgtype.Text        `json:"review_comment"`
	ReviewedAt    pgtype.Timestamptz `json:"reviewed_at"`
	ReviewedBy    pgtype.UUID        `json:"reviewed_by"`
}

// 镜头视频 CRUD（每个镜头的视频片段）
func (q *Queries) CreateShotVideo(ctx context.Context, arg CreateShotVideoParams) (ShotVideo, error) {
	row := q.db.QueryRow(ctx, createShotVideo,
		arg.ShotID,
		arg.ProjectID,
		arg.ShotImageID,
		arg.VideoUrl,
		arg.TaskID,
		arg.Status,
		arg.Duration,
		arg.Provider,
		arg.Model,
		arg.ParamsJson,
		arg.Version,
		arg.ReviewStatus,
		arg.ReviewComment,
		arg.ReviewedAt,
		arg.ReviewedBy,
	)
	var i ShotVideo
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ShotID,
		&i.ProjectID,
		&i.ShotImageID,
		&i.VideoUrl,
		&i.TaskID,
		&i.Status,
		&i.Duration,
		&i.Provider,
		&i.Model,
		&i.ParamsJson,
		&i.Version,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const getShotVideoByID = `-- name: GetShotVideoByID :one
SELECT id, created_at, updated_at, deleted_at, shot_id, project_id, shot_image_id, video_url, task_id, status, duration, provider, model, params_json, version, review_status, review_comment, reviewed_at, reviewed_by FROM shot_videos
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetShotVideoByID(ctx context.Context, id pgtype.UUID) (ShotVideo, error) {
	row := q.db.QueryRow(ctx, getShotVideoByID, id)
	var i ShotVideo
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ShotID,
		&i.ProjectID,
		&i.ShotImageID,
		&i.VideoUrl,
		&i.TaskID,
		&i.Status,
		&i.Duration,
		&i.Provider,
		&i.Model,
		&i.ParamsJson,
		&i.Version,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const getShotVideoByShotPrimary = `-- name: GetShotVideoByShotPrimary :one
SELECT id, created_at, updated_at, deleted_at, shot_id, project_id, shot_image_id, video_url, task_id, status, duration, provider, model, params_json, version, review_status, review_comment, reviewed_at, reviewed_by FROM shot_videos
WHERE shot_id = $1 AND deleted_at IS NULL
ORDER BY version DESC
LIMIT 1
`

func (q *Queries) GetShotVideoByShotPrimary(ctx context.Context, shotID pgtype.UUID) (ShotVideo, error) {
	row := q.db.QueryRow(ctx, getShotVideoByShotPrimary, shotID)
	var i ShotVideo
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ShotID,
		&i.ProjectID,
		&i.ShotImageID,
		&i.VideoUrl,
		&i.TaskID,
		&i.Status,
		&i.Duration,
		&i.Provider,
		&i.Model,
		&i.ParamsJson,
		&i.Version,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const listShotVideosByProject = `-- name: ListShotVideosByProject :many
SELECT id, created_at, updated_at, deleted_at, shot_id, project_id, shot_image_id, video_url, task_id, status, duration, provider, model, params_json, version, review_status, review_comment, reviewed_at, reviewed_by FROM shot_videos
WHERE project_id = $1 AND deleted_at IS NULL
ORDER BY created_at ASC
`

func (q *Queries) ListShotVideosByProject(ctx context.Context, projectID pgtype.UUID) ([]ShotVideo, error) {
	rows, err := q.db.Query(ctx, listShotVideosByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShotVideo{}
	for rows.Next() {
		var i ShotVideo
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ShotID,
			&i.ProjectID,
			&i.ShotImageID,
			&i.VideoUrl,
			&i.TaskID,
			&i.Status,
			&i.Duration,
			&i.Provider,
			&i.Model,
			&i.ParamsJson,
			&i.Version,
			&i.ReviewStatus,
			&i.ReviewComment,
			&i.ReviewedAt,
			&i.ReviewedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShotVideosByShot = `-- name: ListShotVideosByShot :many
SELECT id, created_at, updated_at, deleted_at, shot_id, project_id, shot_image_id, video_url, task_id, status, duration, provider, model, params_json, version, review_status, review_comment, reviewed_at, reviewed_by FROM shot_videos
WHERE shot_id = $1 AND deleted_at IS NULL
ORDER BY version ASC, created_at ASC
`

func (q *Queries) ListShotVideosByShot(ctx context.Context, shotID pgtype.UUID) ([]ShotVideo, error) {
	rows, err := q.db.Query(ctx, listShotVideosByShot, shotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShotVideo{}
	for rows.Next() {
		var i ShotVideo
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ShotID,
			&i.ProjectID,
			&i.ShotImageID,
			&i.VideoUrl,
			&i.TaskID,
			&i.Status,
			&i.Duration,
			&i.Provider,
			&i.Model,
			&i.ParamsJson,
			&i.Version,
			&i.ReviewStatus,
			&i.ReviewComment,
			&i.ReviewedAt,
			&i.ReviewedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteShotVideo = `-- name: SoftDeleteShotVideo :exec
UPDATE shot_videos SET deleted_at = now() WHERE id = $1
`

func (q *Queries) SoftDeleteShotVideo(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteShotVideo, id)
	return err
}

const softDeleteShotVideosByShot = `-- name: SoftDeleteShotVideosByShot :exec
UPDATE shot_videos SET deleted_at = now() WHERE shot_id = $1
`

func (q *Queries) SoftDeleteShotVideosByShot(ctx context.Context, shotID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteShotVideosByShot, shotID)
	return err
}

const updateShotVideo = `-- name: UpdateShotVideo :one
UPDATE shot_videos
SET
    shot_image_id = $1,
    video_url = COALESCE($2, video_url),
    task_id = COALESCE($3, task_id),
    status = COALESCE($4, status),
    duration = COALESCE($5, duration),
    provider = COALESCE($6, provider),
    model = COALESCE($7, model),
    params_json = COALESCE($8, params_json),
    version = COALESCE($9, version),
    review_status = COALESCE($10, review_status),
    review_comment = COALESCE($11, review_comment),
    reviewed_at = $12,
    reviewed_by = $13
WHERE id = $14 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, shot_id, project_id, shot_image_id, video_url, task_id, status, duration, provider, model, params_json, version, review_status, review_comment, reviewed_at, reviewed_by
`

type UpdateShotVideoParams struct {
	ShotImageID   pgtype.UUID        `json:"shot_image_id"`
	VideoUrl      pgtype.Text        `json:"video_url"`
	TaskID        pgtype.Text        `json:"task_id"`
	Status        pgtype.Text        `json:"status"`
	Duration      pgtype.Int4        `json:"duration"`
	Provider      pgtype.Text        `json:"provider"`
	Model         pgtype.Text        `json:"model"`
	ParamsJson    []byte             `json:"params_json"`
	Version       pgtype.Int4        `json:"version"`
	ReviewStatus  pgtype.Text        `json:"review_status"`
	ReviewComment pgtype.Text        `json:"review_comment"`
	ReviewedAt    pgtype.Timestamptz `json:"reviewed_at"`
	ReviewedBy    pgtype.UUID        `json:"reviewed_by"`
	ID            pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateShotVideo(ctx context.Context, arg UpdateShotVideoParams) (ShotVideo, error) {
	row := q.db.QueryRow(ctx, updateShotVideo,
		arg.ShotImageID,
		arg.VideoUrl,
		arg.TaskID,
		arg.Status,
		arg.Duration,
		arg.Provider,
		arg.Model,
		arg.ParamsJson,
		arg.Version,
		arg.ReviewStatus,
		arg.ReviewComment,
		arg.ReviewedAt,
		arg.ReviewedBy,
		arg.ID,
	)
	var i ShotVideo
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ShotID,
		&i.ProjectID,
		&i.ShotImageID,
		&i.VideoUrl,
		&i.TaskID,
		&i.Status,
		&i.Duration,
		&i.Provider,
		&i.Model,
		&i.ParamsJson,
		&i.Version,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const updateShotVideoReview = `-- name: UpdateShotVideoReview :one
UPDATE shot_videos
SET review_status = COALESCE($1, review_status),
    review_comment = COALESCE($2, review_comment),
    reviewed_at = $3,
    reviewed_by = $4
WHERE id = $5 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, shot_id, project_id, shot_image_id, video_url, task_id, status, duration, provider, model, params_json, version, review_status, review_comment, reviewed_at, reviewed_by
`

type UpdateShotVideoReviewParams struct {
	ReviewStatus  pgtype.Text        `json:"review_status"`
	ReviewComment pgtype.Text        `json:"review_comment"`
	ReviewedAt    pgtype.Timestamptz `json:"reviewed_at"`
	ReviewedBy    pgtype.UUID        `json:"reviewed_by"`
	ID            pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateShotVideoReview(ctx context.Context, arg UpdateShotVideoReviewParams) (ShotVideo, error) {
	row := q.db.QueryRow(ctx, updateShotVideoReview,
		arg.ReviewStatus,
		arg.ReviewComment,
		arg.ReviewedAt,
		arg.ReviewedBy,
		arg.ID,
	)
	var i ShotVideo
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ShotID,
		&i.ProjectID,
		&i.ShotImageID,
		&i.VideoUrl,
		&i.TaskID,
		&i.Status,
		&i.Duration,
		&i.Provider,
		&i.Model,
		&i.ParamsJson,
		&i.Version,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const updateShotVideoStatus = `-- name: UpdateShotVideoStatus :one
UPDATE shot_videos
SET video_url = COALESCE($1, video_url),
    task_id = COALESCE($2, task_id),
    status = COALESCE($3, status)
WHERE id = $4 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, shot_id, project_id, shot_image_id, video_url, task_id, status, duration, provider, model, params_json, version, review_status, review_comment, reviewed_at, reviewed_by
`

type UpdateShotVideoStatusParams struct {
	VideoUrl pgtype.Text `json:"video_url"`
	TaskID   pgtype.Text `json:"task_id"`
	Status   pgtype.Text `json:"status"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateShotVideoStatus(ctx context.Context, arg UpdateShotVideoStatusParams) (ShotVideo, error) {
	row := q.db.QueryRow(ctx, updateShotVideoStatus,
		arg.VideoUrl,
		arg.TaskID,
		arg.Status,
		arg.ID,
	)
	var i ShotVideo
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ShotID,
		&i.ProjectID,
		&i.ShotImageID,
		&i.VideoUrl,
		&i.TaskID,
		&i.Status,
		&i.Duration,
		&i.Provider,
		&i.Model,
		&i.ParamsJson,
		&i.Version,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}
