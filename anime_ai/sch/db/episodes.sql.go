// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: episodes.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEpisodesByProject = `-- name: CountEpisodesByProject :one
SELECT COUNT(*)::int FROM episodes
WHERE project_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountEpisodesByProject(ctx context.Context, projectID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, countEpisodesByProject, projectID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createEpisode = `-- name: CreateEpisode :one
INSERT INTO episodes (
    project_id, title, sort_index, summary, status, current_step, current_phase, last_active_at
)
VALUES (
    $1, $2, $3, $4,
    COALESCE($5, 'not_started'), COALESCE($6, 0),
    COALESCE($7, 'story'), $8
)
RETURNING id, created_at, updated_at, deleted_at, project_id, title, sort_index, summary, status, current_step, current_phase, last_active_at
`

type CreateEpisodeParams struct {
	ProjectID    pgtype.UUID        `json:"project_id"`
	Title        pgtype.Text        `json:"title"`
	SortIndex    int32              `json:"sort_index"`
	Summary      pgtype.Text        `json:"summary"`
	Status       interface{}        `json:"status"`
	CurrentStep  interface{}        `json:"current_step"`
	CurrentPhase interface{}        `json:"current_phase"`
	LastActiveAt pgtype.Timestamptz `json:"last_active_at"`
}

func (q *Queries) CreateEpisode(ctx context.Context, arg CreateEpisodeParams) (Episode, error) {
	row := q.db.QueryRow(ctx, createEpisode,
		arg.ProjectID,
		arg.Title,
		arg.SortIndex,
		arg.Summary,
		arg.Status,
		arg.CurrentStep,
		arg.CurrentPhase,
		arg.LastActiveAt,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Title,
		&i.SortIndex,
		&i.Summary,
		&i.Status,
		&i.CurrentStep,
		&i.CurrentPhase,
		&i.LastActiveAt,
	)
	return i, err
}

const getEpisodeByID = `-- name: GetEpisodeByID :one
SELECT id, created_at, updated_at, deleted_at, project_id, title, sort_index, summary, status, current_step, current_phase, last_active_at FROM episodes
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetEpisodeByID(ctx context.Context, id pgtype.UUID) (Episode, error) {
	row := q.db.QueryRow(ctx, getEpisodeByID, id)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Title,
		&i.SortIndex,
		&i.Summary,
		&i.Status,
		&i.CurrentStep,
		&i.CurrentPhase,
		&i.LastActiveAt,
	)
	return i, err
}

const listEpisodesByProject = `-- name: ListEpisodesByProject :many
SELECT id, created_at, updated_at, deleted_at, project_id, title, sort_index, summary, status, current_step, current_phase, last_active_at FROM episodes
WHERE project_id = $1 AND deleted_at IS NULL
ORDER BY sort_index ASC
`

func (q *Queries) ListEpisodesByProject(ctx context.Context, projectID pgtype.UUID) ([]Episode, error) {
	rows, err := q.db.Query(ctx, listEpisodesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.Title,
			&i.SortIndex,
			&i.Summary,
			&i.Status,
			&i.CurrentStep,
			&i.CurrentPhase,
			&i.LastActiveAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteEpisode = `-- name: SoftDeleteEpisode :exec
UPDATE episodes
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) SoftDeleteEpisode(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteEpisode, id)
	return err
}

const softDeleteEpisodesByProject = `-- name: SoftDeleteEpisodesByProject :exec
UPDATE episodes
SET deleted_at = now()
WHERE project_id = $1
`

func (q *Queries) SoftDeleteEpisodesByProject(ctx context.Context, projectID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteEpisodesByProject, projectID)
	return err
}

const updateEpisode = `-- name: UpdateEpisode :one
UPDATE episodes
SET
    title = COALESCE($1, title),
    sort_index = COALESCE($2, sort_index),
    summary = COALESCE($3, summary),
    status = COALESCE($4, status),
    current_step = COALESCE($5, current_step),
    current_phase = COALESCE($6, current_phase),
    last_active_at = $7
WHERE id = $8 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, project_id, title, sort_index, summary, status, current_step, current_phase, last_active_at
`

type UpdateEpisodeParams struct {
	Title        pgtype.Text        `json:"title"`
	SortIndex    pgtype.Int4        `json:"sort_index"`
	Summary      pgtype.Text        `json:"summary"`
	Status       pgtype.Text        `json:"status"`
	CurrentStep  pgtype.Int4        `json:"current_step"`
	CurrentPhase pgtype.Text        `json:"current_phase"`
	LastActiveAt pgtype.Timestamptz `json:"last_active_at"`
	ID           pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateEpisode(ctx context.Context, arg UpdateEpisodeParams) (Episode, error) {
	row := q.db.QueryRow(ctx, updateEpisode,
		arg.Title,
		arg.SortIndex,
		arg.Summary,
		arg.Status,
		arg.CurrentStep,
		arg.CurrentPhase,
		arg.LastActiveAt,
		arg.ID,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Title,
		&i.SortIndex,
		&i.Summary,
		&i.Status,
		&i.CurrentStep,
		&i.CurrentPhase,
		&i.LastActiveAt,
	)
	return i, err
}

const updateEpisodeSortIndex = `-- name: UpdateEpisodeSortIndex :exec
UPDATE episodes
SET sort_index = $1
WHERE id = $2 AND project_id = $3 AND deleted_at IS NULL
`

type UpdateEpisodeSortIndexParams struct {
	SortIndex int32       `json:"sort_index"`
	ID        pgtype.UUID `json:"id"`
	ProjectID pgtype.UUID `json:"project_id"`
}

func (q *Queries) UpdateEpisodeSortIndex(ctx context.Context, arg UpdateEpisodeSortIndexParams) error {
	_, err := q.db.Exec(ctx, updateEpisodeSortIndex, arg.SortIndex, arg.ID, arg.ProjectID)
	return err
}
