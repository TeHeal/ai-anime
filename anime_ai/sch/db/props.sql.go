// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: props.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProp = `-- name: CreateProp :one

INSERT INTO props (
    project_id, name, appearance, is_key_prop, style, style_override,
    image_url, status, source
)
VALUES (
    $1, $2, COALESCE($3, ''),
    COALESCE($4, false), COALESCE($5, ''),
    COALESCE($6, false), COALESCE($7, ''),
    COALESCE($8, 'draft'), COALESCE($9, 'manual')
)
RETURNING id, created_at, updated_at, deleted_at, project_id, name, appearance, is_key_prop, style, style_id, style_override, reference_images_json, image_url, used_by_json, scenes_json, status, source
`

type CreatePropParams struct {
	ProjectID     pgtype.UUID `json:"project_id"`
	Name          string      `json:"name"`
	Appearance    interface{} `json:"appearance"`
	IsKeyProp     interface{} `json:"is_key_prop"`
	Style         interface{} `json:"style"`
	StyleOverride interface{} `json:"style_override"`
	ImageUrl      interface{} `json:"image_url"`
	Status        interface{} `json:"status"`
	Source        interface{} `json:"source"`
}

// 道具资产 CRUD（项目级）
func (q *Queries) CreateProp(ctx context.Context, arg CreatePropParams) (Prop, error) {
	row := q.db.QueryRow(ctx, createProp,
		arg.ProjectID,
		arg.Name,
		arg.Appearance,
		arg.IsKeyProp,
		arg.Style,
		arg.StyleOverride,
		arg.ImageUrl,
		arg.Status,
		arg.Source,
	)
	var i Prop
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Name,
		&i.Appearance,
		&i.IsKeyProp,
		&i.Style,
		&i.StyleID,
		&i.StyleOverride,
		&i.ReferenceImagesJson,
		&i.ImageUrl,
		&i.UsedByJson,
		&i.ScenesJson,
		&i.Status,
		&i.Source,
	)
	return i, err
}

const getPropByID = `-- name: GetPropByID :one
SELECT id, created_at, updated_at, deleted_at, project_id, name, appearance, is_key_prop, style, style_id, style_override, reference_images_json, image_url, used_by_json, scenes_json, status, source FROM props
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPropByID(ctx context.Context, id pgtype.UUID) (Prop, error) {
	row := q.db.QueryRow(ctx, getPropByID, id)
	var i Prop
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Name,
		&i.Appearance,
		&i.IsKeyProp,
		&i.Style,
		&i.StyleID,
		&i.StyleOverride,
		&i.ReferenceImagesJson,
		&i.ImageUrl,
		&i.UsedByJson,
		&i.ScenesJson,
		&i.Status,
		&i.Source,
	)
	return i, err
}

const listPropsByProject = `-- name: ListPropsByProject :many
SELECT id, created_at, updated_at, deleted_at, project_id, name, appearance, is_key_prop, style, style_id, style_override, reference_images_json, image_url, used_by_json, scenes_json, status, source FROM props
WHERE project_id = $1 AND deleted_at IS NULL
ORDER BY name ASC
`

func (q *Queries) ListPropsByProject(ctx context.Context, projectID pgtype.UUID) ([]Prop, error) {
	rows, err := q.db.Query(ctx, listPropsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Prop{}
	for rows.Next() {
		var i Prop
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.Name,
			&i.Appearance,
			&i.IsKeyProp,
			&i.Style,
			&i.StyleID,
			&i.StyleOverride,
			&i.ReferenceImagesJson,
			&i.ImageUrl,
			&i.UsedByJson,
			&i.ScenesJson,
			&i.Status,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProp = `-- name: SoftDeleteProp :exec
UPDATE props SET deleted_at = now() WHERE id = $1
`

func (q *Queries) SoftDeleteProp(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteProp, id)
	return err
}

const updateProp = `-- name: UpdateProp :one
UPDATE props
SET
    name = COALESCE($1, name),
    appearance = COALESCE($2, appearance),
    is_key_prop = COALESCE($3, is_key_prop),
    style = COALESCE($4, style),
    style_override = COALESCE($5, style_override),
    reference_images_json = COALESCE($6, reference_images_json),
    image_url = COALESCE($7, image_url),
    used_by_json = COALESCE($8, used_by_json),
    scenes_json = COALESCE($9, scenes_json),
    status = COALESCE($10, status),
    source = COALESCE($11, source)
WHERE id = $12 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, project_id, name, appearance, is_key_prop, style, style_id, style_override, reference_images_json, image_url, used_by_json, scenes_json, status, source
`

type UpdatePropParams struct {
	Name                pgtype.Text `json:"name"`
	Appearance          pgtype.Text `json:"appearance"`
	IsKeyProp           pgtype.Bool `json:"is_key_prop"`
	Style               pgtype.Text `json:"style"`
	StyleOverride       pgtype.Bool `json:"style_override"`
	ReferenceImagesJson []byte      `json:"reference_images_json"`
	ImageUrl            pgtype.Text `json:"image_url"`
	UsedByJson          []byte      `json:"used_by_json"`
	ScenesJson          []byte      `json:"scenes_json"`
	Status              pgtype.Text `json:"status"`
	Source              pgtype.Text `json:"source"`
	ID                  pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateProp(ctx context.Context, arg UpdatePropParams) (Prop, error) {
	row := q.db.QueryRow(ctx, updateProp,
		arg.Name,
		arg.Appearance,
		arg.IsKeyProp,
		arg.Style,
		arg.StyleOverride,
		arg.ReferenceImagesJson,
		arg.ImageUrl,
		arg.UsedByJson,
		arg.ScenesJson,
		arg.Status,
		arg.Source,
		arg.ID,
	)
	var i Prop
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Name,
		&i.Appearance,
		&i.IsKeyProp,
		&i.Style,
		&i.StyleID,
		&i.StyleOverride,
		&i.ReferenceImagesJson,
		&i.ImageUrl,
		&i.UsedByJson,
		&i.ScenesJson,
		&i.Status,
		&i.Source,
	)
	return i, err
}
