// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: shots.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countShotsByProject = `-- name: CountShotsByProject :one
SELECT COUNT(*)::int FROM shots
WHERE project_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountShotsByProject(ctx context.Context, projectID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, countShotsByProject, projectID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createShot = `-- name: CreateShot :one

INSERT INTO shots (
    project_id, segment_id, scene_id, sort_index, prompt, style_prompt,
    image_url, video_url, task_id, status, duration, camera_type, camera_angle,
    dialogue, character_name, character_id, emotion, voice, voice_name, lip_sync,
    transition, audio_design, priority, negative_prompt, version,
    locked_by, locked_at, review_status, review_comment, reviewed_at, reviewed_by
)
VALUES (
    $1, $2, $3, $4,
    $5, $6, $7, $8,
    $9, COALESCE($10, 'pending'), COALESCE($11, 5),
    $12, $13, $14,
    $15, $16, $17,
    $18, $19, COALESCE($20, '口型同步'),
    $21, $22, $23,
    $24, COALESCE($25, 1),
    $26, $27, $28,
    $29, $30, $31
)
RETURNING id, created_at, updated_at, deleted_at, project_id, segment_id, scene_id, sort_index, prompt, style_prompt, image_url, video_url, task_id, status, duration, camera_type, camera_angle, dialogue, character_name, character_id, emotion, voice, voice_name, lip_sync, transition, audio_design, priority, negative_prompt, version, locked_by, locked_at, review_status, review_comment, reviewed_at, reviewed_by
`

type CreateShotParams struct {
	ProjectID      pgtype.UUID        `json:"project_id"`
	SegmentID      pgtype.UUID        `json:"segment_id"`
	SceneID        pgtype.UUID        `json:"scene_id"`
	SortIndex      int32              `json:"sort_index"`
	Prompt         pgtype.Text        `json:"prompt"`
	StylePrompt    pgtype.Text        `json:"style_prompt"`
	ImageUrl       pgtype.Text        `json:"image_url"`
	VideoUrl       pgtype.Text        `json:"video_url"`
	TaskID         pgtype.Text        `json:"task_id"`
	Status         interface{}        `json:"status"`
	Duration       interface{}        `json:"duration"`
	CameraType     pgtype.Text        `json:"camera_type"`
	CameraAngle    pgtype.Text        `json:"camera_angle"`
	Dialogue       pgtype.Text        `json:"dialogue"`
	CharacterName  pgtype.Text        `json:"character_name"`
	CharacterID    pgtype.UUID        `json:"character_id"`
	Emotion        pgtype.Text        `json:"emotion"`
	Voice          pgtype.Text        `json:"voice"`
	VoiceName      pgtype.Text        `json:"voice_name"`
	LipSync        interface{}        `json:"lip_sync"`
	Transition     pgtype.Text        `json:"transition"`
	AudioDesign    pgtype.Text        `json:"audio_design"`
	Priority       pgtype.Text        `json:"priority"`
	NegativePrompt pgtype.Text        `json:"negative_prompt"`
	Version        interface{}        `json:"version"`
	LockedBy       pgtype.UUID        `json:"locked_by"`
	LockedAt       pgtype.Timestamptz `json:"locked_at"`
	ReviewStatus   pgtype.Text        `json:"review_status"`
	ReviewComment  pgtype.Text        `json:"review_comment"`
	ReviewedAt     pgtype.Timestamptz `json:"reviewed_at"`
	ReviewedBy     pgtype.UUID        `json:"reviewed_by"`
}

// 镜头 CRUD（脚本指令，项目级）
func (q *Queries) CreateShot(ctx context.Context, arg CreateShotParams) (Shot, error) {
	row := q.db.QueryRow(ctx, createShot,
		arg.ProjectID,
		arg.SegmentID,
		arg.SceneID,
		arg.SortIndex,
		arg.Prompt,
		arg.StylePrompt,
		arg.ImageUrl,
		arg.VideoUrl,
		arg.TaskID,
		arg.Status,
		arg.Duration,
		arg.CameraType,
		arg.CameraAngle,
		arg.Dialogue,
		arg.CharacterName,
		arg.CharacterID,
		arg.Emotion,
		arg.Voice,
		arg.VoiceName,
		arg.LipSync,
		arg.Transition,
		arg.AudioDesign,
		arg.Priority,
		arg.NegativePrompt,
		arg.Version,
		arg.LockedBy,
		arg.LockedAt,
		arg.ReviewStatus,
		arg.ReviewComment,
		arg.ReviewedAt,
		arg.ReviewedBy,
	)
	var i Shot
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.SegmentID,
		&i.SceneID,
		&i.SortIndex,
		&i.Prompt,
		&i.StylePrompt,
		&i.ImageUrl,
		&i.VideoUrl,
		&i.TaskID,
		&i.Status,
		&i.Duration,
		&i.CameraType,
		&i.CameraAngle,
		&i.Dialogue,
		&i.CharacterName,
		&i.CharacterID,
		&i.Emotion,
		&i.Voice,
		&i.VoiceName,
		&i.LipSync,
		&i.Transition,
		&i.AudioDesign,
		&i.Priority,
		&i.NegativePrompt,
		&i.Version,
		&i.LockedBy,
		&i.LockedAt,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const getShotByID = `-- name: GetShotByID :one
SELECT id, created_at, updated_at, deleted_at, project_id, segment_id, scene_id, sort_index, prompt, style_prompt, image_url, video_url, task_id, status, duration, camera_type, camera_angle, dialogue, character_name, character_id, emotion, voice, voice_name, lip_sync, transition, audio_design, priority, negative_prompt, version, locked_by, locked_at, review_status, review_comment, reviewed_at, reviewed_by FROM shots
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetShotByID(ctx context.Context, id pgtype.UUID) (Shot, error) {
	row := q.db.QueryRow(ctx, getShotByID, id)
	var i Shot
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.SegmentID,
		&i.SceneID,
		&i.SortIndex,
		&i.Prompt,
		&i.StylePrompt,
		&i.ImageUrl,
		&i.VideoUrl,
		&i.TaskID,
		&i.Status,
		&i.Duration,
		&i.CameraType,
		&i.CameraAngle,
		&i.Dialogue,
		&i.CharacterName,
		&i.CharacterID,
		&i.Emotion,
		&i.Voice,
		&i.VoiceName,
		&i.LipSync,
		&i.Transition,
		&i.AudioDesign,
		&i.Priority,
		&i.NegativePrompt,
		&i.Version,
		&i.LockedBy,
		&i.LockedAt,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const listShotsByProject = `-- name: ListShotsByProject :many
SELECT id, created_at, updated_at, deleted_at, project_id, segment_id, scene_id, sort_index, prompt, style_prompt, image_url, video_url, task_id, status, duration, camera_type, camera_angle, dialogue, character_name, character_id, emotion, voice, voice_name, lip_sync, transition, audio_design, priority, negative_prompt, version, locked_by, locked_at, review_status, review_comment, reviewed_at, reviewed_by FROM shots
WHERE project_id = $1 AND deleted_at IS NULL
ORDER BY sort_index ASC
`

func (q *Queries) ListShotsByProject(ctx context.Context, projectID pgtype.UUID) ([]Shot, error) {
	rows, err := q.db.Query(ctx, listShotsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Shot{}
	for rows.Next() {
		var i Shot
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.SegmentID,
			&i.SceneID,
			&i.SortIndex,
			&i.Prompt,
			&i.StylePrompt,
			&i.ImageUrl,
			&i.VideoUrl,
			&i.TaskID,
			&i.Status,
			&i.Duration,
			&i.CameraType,
			&i.CameraAngle,
			&i.Dialogue,
			&i.CharacterName,
			&i.CharacterID,
			&i.Emotion,
			&i.Voice,
			&i.VoiceName,
			&i.LipSync,
			&i.Transition,
			&i.AudioDesign,
			&i.Priority,
			&i.NegativePrompt,
			&i.Version,
			&i.LockedBy,
			&i.LockedAt,
			&i.ReviewStatus,
			&i.ReviewComment,
			&i.ReviewedAt,
			&i.ReviewedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShotsByScene = `-- name: ListShotsByScene :many
SELECT id, created_at, updated_at, deleted_at, project_id, segment_id, scene_id, sort_index, prompt, style_prompt, image_url, video_url, task_id, status, duration, camera_type, camera_angle, dialogue, character_name, character_id, emotion, voice, voice_name, lip_sync, transition, audio_design, priority, negative_prompt, version, locked_by, locked_at, review_status, review_comment, reviewed_at, reviewed_by FROM shots
WHERE scene_id = $1 AND deleted_at IS NULL
ORDER BY sort_index ASC
`

func (q *Queries) ListShotsByScene(ctx context.Context, sceneID pgtype.UUID) ([]Shot, error) {
	rows, err := q.db.Query(ctx, listShotsByScene, sceneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Shot{}
	for rows.Next() {
		var i Shot
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.SegmentID,
			&i.SceneID,
			&i.SortIndex,
			&i.Prompt,
			&i.StylePrompt,
			&i.ImageUrl,
			&i.VideoUrl,
			&i.TaskID,
			&i.Status,
			&i.Duration,
			&i.CameraType,
			&i.CameraAngle,
			&i.Dialogue,
			&i.CharacterName,
			&i.CharacterID,
			&i.Emotion,
			&i.Voice,
			&i.VoiceName,
			&i.LipSync,
			&i.Transition,
			&i.AudioDesign,
			&i.Priority,
			&i.NegativePrompt,
			&i.Version,
			&i.LockedBy,
			&i.LockedAt,
			&i.ReviewStatus,
			&i.ReviewComment,
			&i.ReviewedAt,
			&i.ReviewedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShotsBySegment = `-- name: ListShotsBySegment :many
SELECT id, created_at, updated_at, deleted_at, project_id, segment_id, scene_id, sort_index, prompt, style_prompt, image_url, video_url, task_id, status, duration, camera_type, camera_angle, dialogue, character_name, character_id, emotion, voice, voice_name, lip_sync, transition, audio_design, priority, negative_prompt, version, locked_by, locked_at, review_status, review_comment, reviewed_at, reviewed_by FROM shots
WHERE segment_id = $1 AND deleted_at IS NULL
ORDER BY sort_index ASC
`

func (q *Queries) ListShotsBySegment(ctx context.Context, segmentID pgtype.UUID) ([]Shot, error) {
	rows, err := q.db.Query(ctx, listShotsBySegment, segmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Shot{}
	for rows.Next() {
		var i Shot
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.SegmentID,
			&i.SceneID,
			&i.SortIndex,
			&i.Prompt,
			&i.StylePrompt,
			&i.ImageUrl,
			&i.VideoUrl,
			&i.TaskID,
			&i.Status,
			&i.Duration,
			&i.CameraType,
			&i.CameraAngle,
			&i.Dialogue,
			&i.CharacterName,
			&i.CharacterID,
			&i.Emotion,
			&i.Voice,
			&i.VoiceName,
			&i.LipSync,
			&i.Transition,
			&i.AudioDesign,
			&i.Priority,
			&i.NegativePrompt,
			&i.Version,
			&i.LockedBy,
			&i.LockedAt,
			&i.ReviewStatus,
			&i.ReviewComment,
			&i.ReviewedAt,
			&i.ReviewedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteShot = `-- name: SoftDeleteShot :exec
UPDATE shots SET deleted_at = now() WHERE id = $1
`

func (q *Queries) SoftDeleteShot(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteShot, id)
	return err
}

const softDeleteShotsByProject = `-- name: SoftDeleteShotsByProject :exec
UPDATE shots SET deleted_at = now() WHERE project_id = $1
`

func (q *Queries) SoftDeleteShotsByProject(ctx context.Context, projectID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteShotsByProject, projectID)
	return err
}

const updateShot = `-- name: UpdateShot :one
UPDATE shots
SET
    segment_id = COALESCE($1, segment_id),
    scene_id = COALESCE($2, scene_id),
    sort_index = COALESCE($3, sort_index),
    prompt = COALESCE($4, prompt),
    style_prompt = COALESCE($5, style_prompt),
    image_url = COALESCE($6, image_url),
    video_url = COALESCE($7, video_url),
    task_id = COALESCE($8, task_id),
    status = COALESCE($9, status),
    duration = COALESCE($10, duration),
    camera_type = COALESCE($11, camera_type),
    camera_angle = COALESCE($12, camera_angle),
    dialogue = COALESCE($13, dialogue),
    character_name = COALESCE($14, character_name),
    character_id = $15,
    emotion = COALESCE($16, emotion),
    voice = COALESCE($17, voice),
    voice_name = COALESCE($18, voice_name),
    lip_sync = COALESCE($19, lip_sync),
    transition = COALESCE($20, transition),
    audio_design = COALESCE($21, audio_design),
    priority = COALESCE($22, priority),
    negative_prompt = COALESCE($23, negative_prompt),
    version = COALESCE($24, version),
    locked_by = $25,
    locked_at = $26,
    review_status = COALESCE($27, review_status),
    review_comment = COALESCE($28, review_comment),
    reviewed_at = $29,
    reviewed_by = $30
WHERE id = $31 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, project_id, segment_id, scene_id, sort_index, prompt, style_prompt, image_url, video_url, task_id, status, duration, camera_type, camera_angle, dialogue, character_name, character_id, emotion, voice, voice_name, lip_sync, transition, audio_design, priority, negative_prompt, version, locked_by, locked_at, review_status, review_comment, reviewed_at, reviewed_by
`

type UpdateShotParams struct {
	SegmentID      pgtype.UUID        `json:"segment_id"`
	SceneID        pgtype.UUID        `json:"scene_id"`
	SortIndex      pgtype.Int4        `json:"sort_index"`
	Prompt         pgtype.Text        `json:"prompt"`
	StylePrompt    pgtype.Text        `json:"style_prompt"`
	ImageUrl       pgtype.Text        `json:"image_url"`
	VideoUrl       pgtype.Text        `json:"video_url"`
	TaskID         pgtype.Text        `json:"task_id"`
	Status         pgtype.Text        `json:"status"`
	Duration       pgtype.Int4        `json:"duration"`
	CameraType     pgtype.Text        `json:"camera_type"`
	CameraAngle    pgtype.Text        `json:"camera_angle"`
	Dialogue       pgtype.Text        `json:"dialogue"`
	CharacterName  pgtype.Text        `json:"character_name"`
	CharacterID    pgtype.UUID        `json:"character_id"`
	Emotion        pgtype.Text        `json:"emotion"`
	Voice          pgtype.Text        `json:"voice"`
	VoiceName      pgtype.Text        `json:"voice_name"`
	LipSync        pgtype.Text        `json:"lip_sync"`
	Transition     pgtype.Text        `json:"transition"`
	AudioDesign    pgtype.Text        `json:"audio_design"`
	Priority       pgtype.Text        `json:"priority"`
	NegativePrompt pgtype.Text        `json:"negative_prompt"`
	Version        pgtype.Int4        `json:"version"`
	LockedBy       pgtype.UUID        `json:"locked_by"`
	LockedAt       pgtype.Timestamptz `json:"locked_at"`
	ReviewStatus   pgtype.Text        `json:"review_status"`
	ReviewComment  pgtype.Text        `json:"review_comment"`
	ReviewedAt     pgtype.Timestamptz `json:"reviewed_at"`
	ReviewedBy     pgtype.UUID        `json:"reviewed_by"`
	ID             pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateShot(ctx context.Context, arg UpdateShotParams) (Shot, error) {
	row := q.db.QueryRow(ctx, updateShot,
		arg.SegmentID,
		arg.SceneID,
		arg.SortIndex,
		arg.Prompt,
		arg.StylePrompt,
		arg.ImageUrl,
		arg.VideoUrl,
		arg.TaskID,
		arg.Status,
		arg.Duration,
		arg.CameraType,
		arg.CameraAngle,
		arg.Dialogue,
		arg.CharacterName,
		arg.CharacterID,
		arg.Emotion,
		arg.Voice,
		arg.VoiceName,
		arg.LipSync,
		arg.Transition,
		arg.AudioDesign,
		arg.Priority,
		arg.NegativePrompt,
		arg.Version,
		arg.LockedBy,
		arg.LockedAt,
		arg.ReviewStatus,
		arg.ReviewComment,
		arg.ReviewedAt,
		arg.ReviewedBy,
		arg.ID,
	)
	var i Shot
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.SegmentID,
		&i.SceneID,
		&i.SortIndex,
		&i.Prompt,
		&i.StylePrompt,
		&i.ImageUrl,
		&i.VideoUrl,
		&i.TaskID,
		&i.Status,
		&i.Duration,
		&i.CameraType,
		&i.CameraAngle,
		&i.Dialogue,
		&i.CharacterName,
		&i.CharacterID,
		&i.Emotion,
		&i.Voice,
		&i.VoiceName,
		&i.LipSync,
		&i.Transition,
		&i.AudioDesign,
		&i.Priority,
		&i.NegativePrompt,
		&i.Version,
		&i.LockedBy,
		&i.LockedAt,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const updateShotImageResult = `-- name: UpdateShotImageResult :one
UPDATE shots
SET image_url = COALESCE($1, image_url),
    task_id = COALESCE($2, task_id),
    status = COALESCE($3, status)
WHERE id = $4 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, project_id, segment_id, scene_id, sort_index, prompt, style_prompt, image_url, video_url, task_id, status, duration, camera_type, camera_angle, dialogue, character_name, character_id, emotion, voice, voice_name, lip_sync, transition, audio_design, priority, negative_prompt, version, locked_by, locked_at, review_status, review_comment, reviewed_at, reviewed_by
`

type UpdateShotImageResultParams struct {
	ImageUrl pgtype.Text `json:"image_url"`
	TaskID   pgtype.Text `json:"task_id"`
	Status   pgtype.Text `json:"status"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateShotImageResult(ctx context.Context, arg UpdateShotImageResultParams) (Shot, error) {
	row := q.db.QueryRow(ctx, updateShotImageResult,
		arg.ImageUrl,
		arg.TaskID,
		arg.Status,
		arg.ID,
	)
	var i Shot
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.SegmentID,
		&i.SceneID,
		&i.SortIndex,
		&i.Prompt,
		&i.StylePrompt,
		&i.ImageUrl,
		&i.VideoUrl,
		&i.TaskID,
		&i.Status,
		&i.Duration,
		&i.CameraType,
		&i.CameraAngle,
		&i.Dialogue,
		&i.CharacterName,
		&i.CharacterID,
		&i.Emotion,
		&i.Voice,
		&i.VoiceName,
		&i.LipSync,
		&i.Transition,
		&i.AudioDesign,
		&i.Priority,
		&i.NegativePrompt,
		&i.Version,
		&i.LockedBy,
		&i.LockedAt,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const updateShotReview = `-- name: UpdateShotReview :one
UPDATE shots
SET review_status = COALESCE($1, review_status),
    review_comment = COALESCE($2, review_comment),
    reviewed_at = $3,
    reviewed_by = $4
WHERE id = $5 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, project_id, segment_id, scene_id, sort_index, prompt, style_prompt, image_url, video_url, task_id, status, duration, camera_type, camera_angle, dialogue, character_name, character_id, emotion, voice, voice_name, lip_sync, transition, audio_design, priority, negative_prompt, version, locked_by, locked_at, review_status, review_comment, reviewed_at, reviewed_by
`

type UpdateShotReviewParams struct {
	ReviewStatus  pgtype.Text        `json:"review_status"`
	ReviewComment pgtype.Text        `json:"review_comment"`
	ReviewedAt    pgtype.Timestamptz `json:"reviewed_at"`
	ReviewedBy    pgtype.UUID        `json:"reviewed_by"`
	ID            pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateShotReview(ctx context.Context, arg UpdateShotReviewParams) (Shot, error) {
	row := q.db.QueryRow(ctx, updateShotReview,
		arg.ReviewStatus,
		arg.ReviewComment,
		arg.ReviewedAt,
		arg.ReviewedBy,
		arg.ID,
	)
	var i Shot
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.SegmentID,
		&i.SceneID,
		&i.SortIndex,
		&i.Prompt,
		&i.StylePrompt,
		&i.ImageUrl,
		&i.VideoUrl,
		&i.TaskID,
		&i.Status,
		&i.Duration,
		&i.CameraType,
		&i.CameraAngle,
		&i.Dialogue,
		&i.CharacterName,
		&i.CharacterID,
		&i.Emotion,
		&i.Voice,
		&i.VoiceName,
		&i.LipSync,
		&i.Transition,
		&i.AudioDesign,
		&i.Priority,
		&i.NegativePrompt,
		&i.Version,
		&i.LockedBy,
		&i.LockedAt,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const updateShotSortIndex = `-- name: UpdateShotSortIndex :exec
UPDATE shots SET sort_index = $1
WHERE id = $2 AND project_id = $3 AND deleted_at IS NULL
`

type UpdateShotSortIndexParams struct {
	SortIndex int32       `json:"sort_index"`
	ID        pgtype.UUID `json:"id"`
	ProjectID pgtype.UUID `json:"project_id"`
}

func (q *Queries) UpdateShotSortIndex(ctx context.Context, arg UpdateShotSortIndexParams) error {
	_, err := q.db.Exec(ctx, updateShotSortIndex, arg.SortIndex, arg.ID, arg.ProjectID)
	return err
}

const updateShotVideoResult = `-- name: UpdateShotVideoResult :one
UPDATE shots
SET video_url = COALESCE($1, video_url),
    task_id = COALESCE($2, task_id),
    status = COALESCE($3, status)
WHERE id = $4 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, project_id, segment_id, scene_id, sort_index, prompt, style_prompt, image_url, video_url, task_id, status, duration, camera_type, camera_angle, dialogue, character_name, character_id, emotion, voice, voice_name, lip_sync, transition, audio_design, priority, negative_prompt, version, locked_by, locked_at, review_status, review_comment, reviewed_at, reviewed_by
`

type UpdateShotVideoResultParams struct {
	VideoUrl pgtype.Text `json:"video_url"`
	TaskID   pgtype.Text `json:"task_id"`
	Status   pgtype.Text `json:"status"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateShotVideoResult(ctx context.Context, arg UpdateShotVideoResultParams) (Shot, error) {
	row := q.db.QueryRow(ctx, updateShotVideoResult,
		arg.VideoUrl,
		arg.TaskID,
		arg.Status,
		arg.ID,
	)
	var i Shot
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.SegmentID,
		&i.SceneID,
		&i.SortIndex,
		&i.Prompt,
		&i.StylePrompt,
		&i.ImageUrl,
		&i.VideoUrl,
		&i.TaskID,
		&i.Status,
		&i.Duration,
		&i.CameraType,
		&i.CameraAngle,
		&i.Dialogue,
		&i.CharacterName,
		&i.CharacterID,
		&i.Emotion,
		&i.Voice,
		&i.VoiceName,
		&i.LipSync,
		&i.Transition,
		&i.AudioDesign,
		&i.Priority,
		&i.NegativePrompt,
		&i.Version,
		&i.LockedBy,
		&i.LockedAt,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}
